{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Agentic makes it easy to create AI agents - autonomous software programs that understand natural language and can use tools to do work on your behalf.</p>"},{"location":"#what-is-agentic","title":"What is Agentic?","text":"<p>Agentic is an opinionated framework that provides:</p> <ul> <li>A lightweight agent framework in the same part of the stack as SmolAgents or PydanticAI</li> <li>A reference implementation of the agent protocol</li> <li>An agent runtime built on threads with support for Ray</li> <li>A suite of \"batteries included\" features to help you get running quickly<ul> <li>Basic RAG features</li> <li>Run history and logging</li> <li>Simple UI examples built with Streamlit and Next.js</li> </ul> </li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Simple but Powerful: Approachable and easy to use, yet flexible enough for complex agent systems</li> <li>Team Collaboration: Support for teams of cooperating agents</li> <li>Human-in-the-Loop: Built-in support for human intervention and guidance</li> <li>Tool Ecosystem: Easy definition and use of tools with a growing library of production-ready tools, as well as the ability to create your own</li> <li>Flexible Deployment: Run agents as standalone applications, API services, or integrated components</li> <li>Framework Interoperability: Work with agents built using other frameworks</li> </ul>"},{"location":"#quick-install","title":"Quick Install","text":"<p>Note If you're on Linux or Windows and installing the <code>rag</code> extra you will need to add <code>--extra-index-url https://download.pytorch.org/whl/cpu</code> to install the CPU version of PyTorch.</p> <pre><code># Install from PyPI\n# For MacOS\nuv pip install \"agentic-framework[all,dev]\"\n\n# For Linux or Windows\nuv pip install \"agentic-framework[all,dev]\" --extra-index-url https://download.pytorch.org/whl/cpu\n\n# Or run from source\ngit clone git@github.com:supercog-ai/agentic.git\n\n# For MacOS\nuv pip install -e \"./agentic[all,dev]\"\n\n# For Linux or Windows\nuv pip install -e \"./agentic[all,dev]\" --extra-index-url https://download.pytorch.org/whl/cpu\n\n# Initialize your project\nagentic init .\n</code></pre>"},{"location":"#hello-world-example","title":"Hello World Example","text":"<pre><code>from agentic.common import Agent, AgentRunner\nfrom agentic.tools import WeatherTool\n\nweather_agent = Agent(\n    name=\"Weather Agent\",\n    welcome=\"I can give you some weather reports! Just tell me which city.\",\n    instructions=\"You are a helpful assistant.\",\n    tools=[WeatherTool()],\n    model=\"openai/gpt-4o-mini\"\n)\n\nif __name__ == \"__main__\":\n    AgentRunner(weather_agent).repl_loop()\n</code></pre>"},{"location":"#ready-to-run-agents","title":"Ready-to-Run Agents","text":"<p>Agentic comes with several pre-built agents you can run immediately:</p> <ul> <li>OSS Deep Researcher: Writes detailed research papers on any topic with references</li> <li>OSS Operator: Full browser automation with authenticated sessions</li> <li>Podcast Producer: Auto-produces and publishes daily podcasts</li> <li>Meeting Notetaker: Records and summarizes meetings</li> <li>Database Agent: Text-to-SQL for data analysis using natural language</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started Guide - Step-by-step introduction to Agentic</li> <li>Core Concepts - Understand the fundamental ideas behind the framework</li> <li>Examples - Explore real-world agent examples</li> <li>CLI Reference - Command-line interface documentation</li> </ul>"},{"location":"FLOWS/","title":"ReAct Agent","text":"<p>This is the default form for Agentic agents.</p>"},{"location":"FLOWS/#pipeline","title":"Pipeline","text":"<p>A pipeline strings together the outputs-&gt;inputs of a set of agents in a linear sequence.</p> <pre><code>from agentic import Agent, Pipeline\n\npipeline = Pipeline(\n    Agent(name=\"agent 1\"),\n    Agent(name=\"agent 2\"),\n    Agent(name=\"agent 3\"),\n)\n\nAgentRunner(pipeline).run()\n</code></pre>"},{"location":"Internals/","title":"Agentic Internals","text":""},{"location":"Internals/#core-data-model","title":"Core data model","text":"<p>The base ReAct agent is implemented by the <code>ActorBaseAgent</code> class in <code>actor_agents.py</code>.  It manages the agent loop and the current LLM context, via its <code>history</code> attribute. This class calls the <code>completion</code> API from <code>Litellm</code> to generate LLM completions for each step when running an agent.</p> <p>External callers operate agents via a proxy class which provides the interface to the agent. Generally the proxy keeps track of multiple requests, and it creates an instance of <code>ActorBaseAgent</code> to hold the state and process operations for each (parallel) request. The proxy runs the agent via a separate thread, and dispatches events from a Queue from the caller's thread.</p> <p>The proxy class manages these concerns:</p> <ul> <li>creates separate agent instances to manage parallel operations</li> <li>dispatches events to the RunManager for persistence</li> <li>binds tools properly to the underlying agent instance</li> <li>manages an event queue for dispatching agent events to the caller</li> <li>parses a JSON string result from the LLM into the requsted result model</li> <li>manages running the FastAPI app for the agent</li> </ul> <p>You can implement custom agents by subclassing <code>BaseAgentProxy</code>. You should call the base constructor in your <code>__init__</code> method, then implement the <code>next_turn</code> method to process operation requests. That method should <code>yield</code> events as your agent runs.</p> <p>Any instance of <code>BaseAgentProxy</code> can be used as a tool by another agent.</p>"},{"location":"Internals/#choosing-the-runtime-engine","title":"Choosing the runtime engine","text":"<p>There are two agent runtimes: one uses basic threads, and the other runs your agent via the Ray distributed processing system. The thread runtime, implemented via <code>LocalAgentProxy</code>, is chosen by default. Set <code>AGENTIC_USE_RAY</code> to enable the Ray runtime:</p> <pre><code>AGENTIC_USE_RAY=1 python examples/basic_agent.py\n</code></pre> <p>The import <code>agentic.common.Agent</code> will reference the active runtime proxy class, either <code>LocalAgentProxy</code> or <code>RayAgentProxy</code>.</p> <p>One big difference when using the <code>Ray</code> engine is that all events and data in and out of your agent must be picklable.</p>"},{"location":"Internals/#agent-processing-flow","title":"Agent processing flow","text":"<p>Forward direction processing happens by sending events to agent, which may send events to sub-agents, and those agents emit events back with results.</p>"},{"location":"Internals/#special-tool-results","title":"Special tool results:","text":"<p><code>PauseForChildResult</code>  - Put the agent in a paused state, and wait for <code>TurnEnd</code> to come back from a sub-agent call. Assumes the event has already been sent to the child.</p> <p><code>PauseForInputResult</code>  - Put the agent in a paused state, and emit a <code>WaitForInput</code> event back to the caller. Wait for the <code>ResumeWithInput</code> event to come back from the caller.</p> <p><code>FinishAgentResult</code> - Special result to indicate that we have sent a handoff Prompt to the next agent, and this agent can finish execution (without sending TurnEnd).</p> <p>When Agent A calls Agent B, it sends a <code>Prompt</code> message and then enters a \"pause\" state (by having the sub-agent tool call return <code>PauseForChildResult</code>).</p> <p>The pause state is mid-way through an LLM function call. When the <code>TurnEnd</code> event is  received from agent B then Agent A can resume by processing the result as the result of the tool call.</p> <p>When Agent A wants to \"pause for human\", then it needs makes a local tool call which returns a <code>PauseForInputResult</code> result. This puts the agent in a paused state and its emits a <code>WaitForInput</code> event back to the caller.  The caller should collect input and send a <code>ResumeWithInput</code> back to agent A. Agent A handles this event by re-calling the tool function with the human input. The tool function can process or return the value as is. Agent A then processes this as the result of the original tool call.</p> <p>So Agent A can be paused waiting on upstream or downstream, but resuming processing looks the same: treat the result as the result of a function call and continue processing.</p>"},{"location":"Internals/#handoff","title":"Handoff","text":"<p>Handoff is when agent A calls agent B, but then \"hands off\" its turn to Agent B. Agent A stops processing. Agent B assumes current context, the original caller, the original depth, and is expected to emit the <code>TurnEnd</code> event back to the original caller. It should also emit the </p>"},{"location":"Internals/#case-1-normal-sub-agent-call-with-pauseforchildresult","title":"Case 1: Normal Sub-Agent Call with PauseForChildResult","text":"<pre><code>%% Case 1: Normal Sub-Agent Call with PauseForChildResult\nsequenceDiagram\n    participant caller\n    participant Agent A\n    participant Agent B\n\n    caller-&gt;&gt;Agent A: Event\n    Note over Agent A: Process Event\n    Agent A-&gt;&gt;Agent B: Prompt\n    Note over Agent A: Return PauseForChildResult\n    Note over Agent A: Enter Paused State\n    Agent B-&gt;&gt;Agent A: TurnEnd\n    Note over Agent A: Resume Processing\n    Agent A-&gt;&gt;caller: TurnEnd\n</code></pre>"},{"location":"Internals/#case-2-pause-for-human-input","title":"Case 2: Pause for Human Input","text":"<pre><code>%% Case 2: Pause for Human Input\nsequenceDiagram\n    participant human\n    participant caller\n    participant Agent A\n\n    caller-&gt;&gt;Agent A: Event\n    Note over Agent A: Process Event\n    Note over Agent A: Tool returns PauseForInputResult\n    Agent A-&gt;&gt;caller: WaitForInput\n    caller-&gt;&gt;human: Request Input\n    human-&gt;&gt;caller: Provide Input\n    caller-&gt;&gt;Agent A: ResumeWithInput\n    Note over Agent A: Re-call tool with input\n    Note over Agent A: Continue Processing\n    Agent A-&gt;&gt;caller: TurnEnd\n</code></pre>"},{"location":"Internals/#case-3-handoff-to-another-agent","title":"Case 3: Handoff to Another Agent","text":"<pre><code>%% Case 3: Handoff to Another Agent\nsequenceDiagram\n    participant caller\n    participant Agent A\n    participant Agent B\n\n    caller-&gt;&gt;Agent A: Event\n    Note over Agent A: Process Event\n    Agent A-&gt;&gt;Agent B: Prompt\n    Note over Agent A: Return FinishAgentResult\n    Note over Agent A: Stop Processing\n    Note over Agent B: Assume Context &amp; Depth\n    Agent B-&gt;&gt;caller: TurnEnd\n</code></pre>"},{"location":"Internals/#ray-actor-logic","title":"Ray Actor logic","text":"<p>Each running agent is execute by a remote Ray object. This means that we call its methods via Ray and they return Promises to get their results. We have to call <code>ray.get</code> to retrieve or wait for the actual result.</p> <p>Our basic agent execution loop looks like:</p> <pre><code>user input -&gt;\n    remote_gen = agent.receiveMessage.remote(Prompt())\n        (agent starts the LLM \"turn\" loop, calling LLM completions and yielding events)\n    for next_ref in remote_gen:\n        event = ray.get(next_ref)  # Prompt handling yields events until turn is over\n</code></pre> <p>If our agent needs to call another agent, it creates the Agent and calls it via Ray remote:</p> <pre><code>user input -&gt;\n    remote_gen = \n        (agent starts the LLM \"turn\" loop, calling LLM completions and yielding events)\n    for next_ref in agent.receiveMessage.remote(Prompt()):\n            # Agent does a function call to a child. \n            agent -&gt; starts sub_agent\n                agent -&gt; iterate over Prompt\n                    sub_agent yield Event\n                agent yield Event\n        event = ray.get(next_ref)  # Prompt handling yields events until turn is over\n</code></pre> <p>If the child call is a <code>handoff</code> then the parent agent simply gives the child agent the same <code>depth</code>, and once the child is done then the parent agent finishes without generating the <code>TurnEnd</code> event, since the child already did.</p>"},{"location":"Internals/#pause-and-resume","title":"Pause and Resume","text":"<p>To support \"human in the loop\", the agent can \"pause\" execution by saving its state, yielding a <code>WaitForInput</code> event, then returning from its loop. Now the caller should send the <code>ResumeWithInput</code> event to the agent which will continue executing from where it left off.</p> <p>If a sub agent needs to Pause, then it emits the WaitForInput event, and all parent agents pause and re-yield that event. They save their context of the child call and restore it when the Resume event is received.</p>"},{"location":"Settings/","title":"Settings","text":""},{"location":"Settings/#setting-debugging-preference","title":"Setting Debugging Preference","text":"<p>$ export AGENTIC_DEBUG=agents|tools|llm|all</p> <p>you can combine flags or just use 'all' for everything.</p> <p>$ export AGENTIC_OVERRIDE_MODEL=xx</p> <p>Force all agents to use the indicated model regardless of their configuration. Uses the <code>Litellm</code>  qualified model names.</p>"},{"location":"Settings/#configuring-the-database-for-thread-logging","title":"Configuring the database for thread logging","text":"<p>Set <code>AGENTIC_DATABASE_URL</code> to configure the db connection for storing Agent threads and thread logs.</p> <p>$ export AGENTIC_DATABASE_URL=postgres://...</p>"},{"location":"agent-memory/","title":"Agent Memory","text":"<p>Agents support multiple types of memory:</p> <ul> <li>Short term memory in \"run history\" (the chat session) of the agent. Run history consumes much of the LLM context that the LLM operates on. Agents include this memory type by default.</li> </ul> <p>You can clear your agent's short term memory:</p> <p><code>runner.reset_session()</code></p> <ul> <li>Persistent facts. Facts and data can be stored anywhere, and applied to the agent context when it runs. Agents expose a <code>memories</code> attribute to make loading memories easy:</li> </ul> <pre><code>uploader = Agent(\n    name=\"TransistorFM\",\n    memories=[\"Default show ID is 60214\"],\n)\n</code></pre> <p>but you can also use a <code>ContextManager</code> to inject information into the agent context.</p> <ul> <li> <p>Run history. Agents can persist their \"run histories\" (chat sessions) so that those runs can be reviewed later.</p> </li> <li> <p>Larger-than-context memory. There are multiple systems for storing memories for your agent that exceed the context window limits. The most popular is RAG - retrieval augmented generation. This system allows your agent to store lots and lots of data and intelligently \"retrieve\" only part of it to help it answer (\"generate\") a question.</p> </li> </ul>"},{"location":"data-model/","title":"Data Model","text":"<p><code>Agent</code> - a named unit of execution which supports one or more operations and maintains a persistent state.</p> <p><code>Thread</code> - when you interact with an agent you do so in the context of a \"thread\", which maintains a history of interactions (events in and events out) with the agent. A Thread has no definite \"end\" state.</p> <p><code>Run</code> - requesting the agent to perform an operation constitutes a \"run\". So Threads are composed of a sequence of Runs. A Run might be in-process, interrupted, continued, or completed.</p> <p><code>Event</code> - as the agent runs it publishes events, keyed to the Run and the Thread.</p> <p>?? \"request_id\"</p>"},{"location":"example-agents/","title":"Example Agents","text":"<p>Agentic comes with several pre-built agents that demonstrate the framework's capabilities. All example agents can be found in the <code>examples</code> folder of the GitHub repository.</p>"},{"location":"example-agents/#basic-agent","title":"Basic Agent","text":"<p>The Basic Agent is the simplest \"hello world\" example, demonstrating how to create an agent with access to tools. It uses the WeatherTool to answer questions about current weather conditions in various locations. This agent is ideal for beginners to understand the core concepts of the Agentic framework, showing how to:</p> <ul> <li>Define an agent with a name, welcome message, and instructions</li> <li>Attach tools to an agent</li> <li>Run an agent in interactive mode</li> </ul> <p>The Basic Agent serves as an excellent starting point for anyone new to the framework, requiring minimal setup while demonstrating the fundamental agent-tool interaction pattern.</p>"},{"location":"example-agents/#oss-deep-researcher","title":"OSS Deep Researcher","text":"<p>The OSS Deep Researcher performs comprehensive web research on any topic and writes a detailed, multiple-page report based on its findings. This complex agent exemplifies a \"plan and execute\" approach, orchestrating a team of specialized sub-agents across multiple steps:</p> <ol> <li>Gathers the research topic from the user and generates initial web search queries</li> <li>Uses the search results to create a structured report plan with sections</li> <li>For each section, generates targeted search queries to gather specific information</li> <li>Drafts each section based on the research findings</li> <li>Reviews and refines each section with context from the entire report</li> <li>Generates comprehensive source references</li> </ol> <p>The Deep Researcher showcases advanced agent orchestration techniques, web research capabilities, and document generation. It's an excellent example of how complex workflows can be managed through the Agentic framework, making it ideal for educational, research, or content creation applications.</p>"},{"location":"example-agents/#oss-operator","title":"OSS Operator","text":"<p>The OSS Operator agent provides intelligent, LLM-directed browser automation. This agent can fully interact with any website, filling forms, clicking buttons, navigating pages, and extracting information based on natural language instructions. It uses the BrowserUseTool which leverages Playwright for browser automation.</p> <p>Key capabilities include:</p> <ul> <li>Full web interaction through natural language commands</li> <li>Visual reasoning to understand web page elements</li> <li>Screenshot capture and analysis</li> <li>Form filling and submission</li> <li>Navigation across multiple pages</li> <li>Session persistence (optional)</li> </ul> <p>The OSS Operator can be configured to use your actual Chrome browser instance, including your cookies and local storage, making it powerful for automating tasks that require authenticated sessions. This agent is particularly useful for web scraping, data collection, form automation, and testing web applications.</p>"},{"location":"example-agents/#meeting-notetaker","title":"Meeting Notetaker","text":"<p>The Meeting Notetaker agent can join online meetings to record, transcribe, and summarize them. It creates comprehensive meeting summaries that can be reviewed later and stores both summaries and transcripts in a RAG (vector store) index for future reference.</p> <p>Key features include:</p> <ul> <li>Joining meetings through provided URLs</li> <li>Real-time recording and transcription</li> <li>Generating structured meeting summaries</li> <li>Building a searchable knowledge base of past meetings</li> <li>Answering questions about meeting content using RAG</li> </ul> <p>This agent demonstrates how Agentic can be used for practical workplace applications, combining real-time processing with knowledge management. It's particularly useful for teams looking to maintain institutional knowledge and improve meeting documentation.</p>"},{"location":"example-agents/#podcast-producer","title":"Podcast Producer","text":"<p>The Podcast Producer agent automatically creates and publishes daily podcasts. The agent handles the complete workflow from content generation to audio production and publication. It showcases how to: - Use text-to-speech tools for audio content generation - Integrate with third-party APIs (Transistor.fm) - Handle multi-stage content workflows</p>"},{"location":"example-agents/#short-podcast-agent","title":"Short Podcast Agent","text":"<p>The Short Podcast Agent demonstrates the use of agent teams and pipelines in Agentic.</p> <p>Key features:</p> <ul> <li>Multi-agent team with AI, sports, and finance reporters</li> <li>Compiles short daily summary using a producer agent</li> <li>Publishes audio via Transistor.fm API</li> </ul> <p>This example is particularly valuable for understanding how to coordinate multiple agents to accomplish complex tasks that involve content creation, transformation, and distribution.</p>"},{"location":"example-agents/#long-podcast-agent","title":"Long Podcast Agent","text":"<p>The Long Podcast Agent creates longer, more in-depth podcasts.</p> <p>Key features:</p> <ul> <li>Scrapes and downloads news articles</li> <li>Summarizes articles and converts to audio</li> <li>Stitches segments and publishes via Transistor.fm API</li> </ul> <p>Steps to set up ngrok devtunnel (to host audio url):</p> <ol> <li>Download ngrok</li> <li>Login, retrieve auth token and run <code>ngrok config add-authtoken &lt;your_auth_token&gt;</code></li> <li>Start local server by running <code>python -m http.server 8000</code></li> <li>In a separate terminal, run <code>ngrok http 8000</code></li> <li>Use the output url as the <code>base_url</code> (e.g. <code>https://&lt;your-ngrok-id&gt;.ngrok-free.app</code>)</li> </ol> <p>This example demonstrates how to produce long-form content using external tools and APIs for content gathering, transformation, and distribution.</p>"},{"location":"example-agents/#database-agent","title":"Database Agent","text":"<p>The Database Agent demonstrates basic Text-to-SQL capabilities for performing data analysis using natural language. This agent connects to a database and allows users to:</p> <ul> <li>Query database structure and schema</li> <li>Ask questions about the data in plain English</li> <li>Get results from complex SQL queries without writing any SQL</li> <li>Explore data relationships and patterns</li> </ul> <p>The Database Agent shows how Agentic can be used for data analysis tasks, making databases accessible through natural language. It's an excellent example of how the framework can bridge complex technical systems with intuitive interfaces, allowing non-technical users to interact with databases without SQL knowledge.</p>"},{"location":"example-agents/#github-agent","title":"GitHub Agent","text":"<p>The GitHub Agent enables interaction with GitHub repositories through natural language. This agent leverages the GitHub API to:</p> <ul> <li>Search repositories for specific code or content</li> <li>Create, view, and manage issues</li> <li>Generate pull requests</li> <li>Access repository statistics and information</li> <li>Browse file structures and content</li> </ul> <p>The agent maintains context about recently viewed repositories and has built-in memory to improve interactions. This example demonstrates how to create tools that integrate with external APIs and services, while providing a natural language interface to complex systems.</p>"},{"location":"example-agents/#next-steps","title":"Next Steps","text":"<ul> <li>Learn more about the Tools that power these agents - each tool has a basic demo agent you can run</li> <li>Check out RAG Support to give your agents access to your own knowledge base</li> <li> <p>Build your own Agents! Think about some of these ideas, or come up with your own:</p> <ul> <li> <p>Build a \"conversational assistant\" agent that can answer questions from private documents, or by retrieving information live from systems like JIRA or Salesforce.</p> </li> <li> <p>Build a customer service agent that answers questions from a RAG index plus live data sources  (status of orders, status of tickets, etc...).</p> </li> <li> <p>Adapt the Deep Research agent to do research projects inside your company. Either connect live data sources via search APIs (like Google Docs search, or Salesforce SOQL), or build a  RAG index that contains docs and knowledge from your company.</p> </li> <li> <p>Create an agent that uses browser automation to gather information from a site that requires user login, and store that information in a structured form like a spreadsheet.</p> </li> <li> <p>Create an agent that does people+company research from a list of leads in a spreadsheet, writing the research data back into the spreadsheet.</p> </li> </ul> </li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will walk you through installing Agentic, setting up your first agent, and understanding how it works.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Note: Agentic requires Python 3.12. It does not work with Python 3.13+ due to Ray compatibility issues.</p> <p>Before you begin, ensure you have the following:</p> <ul> <li>Python 3.12</li> <li><code>uv</code> - a Python package manager (installation instructions)</li> <li><code>node</code> &amp; <code>npm</code> Optional - used for building the frontend dashboard (installation instructions)</li> <li><code>git</code> Optional - used for cloning from source (installation instructions)</li> </ul>"},{"location":"getting-started/#installation-setup","title":"Installation &amp; Setup","text":""},{"location":"getting-started/#1-set-up-a-project-directory","title":"1. Set up a project directory","text":"<p>Set up a directory to hold your agentic project, and create a virtual environment using <code>uv</code>:</p> <pre><code>mkdir -p ~/agentic\ncd ~/agentic\nuv venv --python 3.12\nsource .venv/bin/activate\n</code></pre>"},{"location":"getting-started/#2-install-agentic","title":"2. Install Agentic","text":"<p>To install Agentic you can either install from source or from PyPI.</p> <p>Note: In this guide we'll install the <code>all</code> extra which includes all tools and features. To customize your installation, see the pyproject.toml for a list of all available extras.</p> <p>If you're on Linux or Windows you will need to add <code>--extra-index-url https://download.pytorch.org/whl/cpu</code> to install the CPU version of PyTorch.</p>  Source   PyPI  <pre><code>git clone git@github.com:supercog-ai/agentic.git\n\n# For MacOS\nuv pip install -e \"./agentic[all]\"\n\n# For Linux or Windows\nuv pip install -e \"./agentic[all]\" \\\n--extra-index-url https://download.pytorch.org/whl/cpu\n</code></pre> <pre><code># For MacOS\nuv pip install \"agentic-framework[all]\"\n\n# For Linux or Windows\nuv pip install \"agentic-framework[all]\" \\\n--extra-index-url https://download.pytorch.org/whl/cpu\n</code></pre>"},{"location":"getting-started/#3-initialize-agentic","title":"3. Initialize Agentic","text":"<p>Initialize Agentic in your project directory:</p> <pre><code>agentic init .\n</code></pre> <p>The initialization will copy examples and a basic file structure into the directory <code>agents</code>.</p> <pre><code>.\n\u251c\u2500\u2500 agents                  # Your agents\n\u251c\u2500\u2500 examples                # Example agents made by us\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 agentic_oracle.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ...                 # Other examples\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 tool_builder.py\n\u251c\u2500\u2500 runtime                 # Runtime data (cli history, run logs, etc)\n\u251c\u2500\u2500 tests                   # Space to put your tests\n\u2514\u2500\u2500 tools                   # Space to put custom tools\n</code></pre>"},{"location":"getting-started/#4-configure-secrets","title":"4. Configure Secrets","text":"<p>Agentic stores settings and secrets in a sqlite database on your machine. The file is located at <code>~/.agentic/agentsdb</code>. </p> <p>To run agents you'll need at least one llm api key configured. Go to our models page for a list of supported models. You can set api keys using the <code>agentic secrets</code> command:</p> <pre><code>agentic secrets set OPENAI_API_KEY=...\n</code></pre> <p>Note: You can also optionally create a <code>.env</code> file in the root of your project directory to store your secrets.</p>"},{"location":"getting-started/#creating-your-first-agent","title":"Creating Your First Agent","text":"<p>Let's build our first agent - a simple weather reporting agent.</p> <p>Create a new file <code>./agents/weather.py</code>, and add this code:</p> <pre><code>from agentic.common import Agent, AgentRunner\nfrom agentic.tools import WeatherTool\n\nweather_agent = Agent(\n    name=\"Weather Agent\",\n    welcome=\"I can give you some weather reports! Just tell me which city.\",\n    instructions=\"You are a helpful assistant.\",\n    tools=[WeatherTool()],\n    model=\"openai/gpt-4o-mini\"\n)\n\nif __name__ == \"__main__\":\n    AgentRunner(weather_agent).repl_loop()\n</code></pre>"},{"location":"getting-started/#running-your-agent","title":"Running Your Agent","text":""},{"location":"getting-started/#using-the-cli","title":"Using the CLI","text":"<pre><code>python agents/weather.py\n</code></pre> <p>You should see output like:</p> <pre><code>I can give you some weather reports! Just tell me which city.\npress &lt;ctrl-d&gt; to quit\n[Weather Agent]&gt; What does the weather look like in NYC?\nThe current weather in New York City is as follows:\n\n- **Temperature:** 17.4\u00b0C\n- **Feels Like:** 9.7\u00b0C\n- **Wind Speed:** 7.1 km/h\n- **Wind Direction:** 221\u00b0\n- **Precipitation:**  0.3 mm\n- **Cloud Cover:** 100%\n- **Wind Gusts:** 19.8 km/h\n- **Relative Humidity:** 80%\n- **Visibility:** 17,900 m\n- **UV Index:** 0.0\n\nIt seems to be quite cloudy, and the temperature feels cooler than the actual temperature.\n[openai/gpt-4o-mini: 2 calls, tokens: 162 -&gt; 144, 0.02 cents, time: 3.81s tc: 0.02 c, ctx: 306]\n[Weather Agent]&gt; \n</code></pre>"},{"location":"getting-started/#using-the-nextjs-dashboard","title":"Using the Next.js Dashboard","text":"<p>Running your agents in the dashboard is a great way to visualize your agents and their interactions:</p> <pre><code>agentic dashboard start --agent-path ./agents/weather.py\n</code></pre> <p></p> <p>Congratulations! You've created an agent powered by the GPT-4o-mini LLM, and given it a tool which it can use to retrieve weather reports (provided by Open-meteo).</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn more about Agent Concepts</li> <li>Learn how to create your own Tools</li> <li>Explore the Database Agent for a basic Text-to-SQL agent</li> <li>Discover how to build Agent Teams</li> </ul>"},{"location":"glossary/","title":"Glossary","text":""},{"location":"glossary/#a","title":"A","text":""},{"location":"glossary/#agentic","title":"Agentic","text":"<p>Our opinionated framework for creating AI agents! Agentic is an easy-to-use, developer-first framework with the goal of mass agent development for everyone from hobbiests to professionals.</p>"},{"location":"glossary/#agent","title":"Agent","text":"<p>A named unit of execution powered by an LLM that supports operations, maintains state, and uses tools to interact with the world. An agent has instructions, tools, and context which it uses to perform tasks.</p>"},{"location":"glossary/#agent-protocol","title":"Agent Protocol","text":"<p>A reference implementation built by us that standardizes how agents communicate and operate, enabling interoperability between different agent frameworks.</p>"},{"location":"glossary/#agent-teams","title":"Agent Teams","text":"<p>A group of specialized agents working together to solve a larger problem. Agents on the team have distinct functions and capabilities. This is usually constructed with an orchestrator agent that calls other agents as tools. Deep Researcher Example</p>"},{"location":"glossary/#agentrunner","title":"<code>AgentRunner</code>","text":"<p>A utility class that provides a REPL interface for interacting with agents via the CLI. Running one of our example agent files with start the agent runner: e.g. <code>python examples/basic_agent.py</code>.</p>"},{"location":"glossary/#b","title":"B","text":""},{"location":"glossary/#baseagentproxy","title":"<code>BaseAgentProxy</code>","text":"<p>A base class for implementing custom agents. Handles concerns like event dispatching, tool binding, and parallel operations.</p>"},{"location":"glossary/#c","title":"C","text":""},{"location":"glossary/#chat-history","title":"Chat History","text":"<p>The running record of turns between the agent and user in the current thread. Consumes part of the LLM context window.</p>"},{"location":"glossary/#context-window","title":"Context Window","text":"<p>The number of tokens an agent can utilize when executing in a thread. Each LLM has a different context window. Smaller context windows lower execution costs but also limit ability.</p>"},{"location":"glossary/#d","title":"D","text":""},{"location":"glossary/#depth","title":"Depth","text":"<p>An attribute of events that indicates how deep in the agent call tree the event originated. Depth is increased by one for each level down the agent tree an event is emitted from. An event emmited by the orchestrating agent has a depth of 0, an event emitted by a child agent would have a depth of 1, etc.</p>"},{"location":"glossary/#e","title":"E","text":""},{"location":"glossary/#event","title":"Event","text":"<p>Data emitted during agent execution, such as chat output, tool calls and results, or completion events. Events are keyed to specific runs and threads. See Event System and Event Types for more information.</p>"},{"location":"glossary/#f","title":"F","text":""},{"location":"glossary/#function-calling","title":"Function Calling","text":"<p>The protocol where an LLM generates a structured text block that is parsed into a tool's function call, allowing agents to use tools.</p>"},{"location":"glossary/#h","title":"H","text":""},{"location":"glossary/#handoff","title":"Handoff","text":"<p>When one agent transfers control to another agent, stopping its own processing. The second agent assumes the context, caller relationship, and depth of the first agent.</p>"},{"location":"glossary/#human-in-the-loop","title":"Human-in-the-Loop","text":"<p>A design pattern where agents pause execution to request input from human operators, then resume processing with that input.</p>"},{"location":"glossary/#i","title":"I","text":""},{"location":"glossary/#instructions","title":"Instructions","text":"<p>The system guidelines provided to an agent that define its purpose, behavior, and approach to tasks. Instructions can range from general guidance (\"You are a helpful assistant\") to specific step-by-step procedures for completing complex tasks. They essentially program the agent's behavior by steering the underlying LLM in a particular direction. Good instructions are clear, specific about the agent's role, and provide appropriate guardrails for the desired behavior.</p>"},{"location":"glossary/#l","title":"L","text":""},{"location":"glossary/#litellm","title":"Litellm","text":"<p>An open source package that Agentic uses to make calls to LLMs.</p>"},{"location":"glossary/#llm-large-language-model","title":"LLM (Large Language Model)","text":"<p>The AI model powering an agent's reasoning and text generation capabilities. Agentic supports various LLMs through Litellm.</p>"},{"location":"glossary/#localagentproxy","title":"<code>LocalAgentProxy</code>","text":"<p>An implementation of the agent runtime that uses basic threads for execution. This is the runtime that is used by default.</p>"},{"location":"glossary/#m","title":"M","text":""},{"location":"glossary/#mcp-model-context-protocol","title":"MCP (Model Context Protocol)","text":"<p>A protocol developed by Anthropic for tools that extends the capabilities of LLMs. It allows for easy tool integration into Agentic.</p>"},{"location":"glossary/#memory","title":"Memory","text":"<p>The various ways agents store and retrieve information, including short-term (run history), persistent facts, and RAG-based vector storage. With Agentic you can implement long-term memory by adding <code>memories (list[str])</code> to your agent declaration.</p>"},{"location":"glossary/#o","title":"O","text":""},{"location":"glossary/#ollama","title":"Ollama","text":"<p>A system for running local LLM models that Agentic supports for agent operation.</p>"},{"location":"glossary/#p","title":"P","text":""},{"location":"glossary/#pipeline","title":"Pipeline","text":"<p>A pattern for connecting multiple agents in sequence, where the output of one agent is used as input for the next.</p>"},{"location":"glossary/#prompt","title":"Prompt","text":"<p>A message sent to an agent to request it to perform an operation. This initiates a run.</p>"},{"location":"glossary/#r","title":"R","text":""},{"location":"glossary/#rag-retrieval-augmented-generation","title":"RAG (Retrieval Augmented Generation)","text":"<p>A local knowledge base that indexes documents and media into a vector database. This information can then be queried by the agent at runtime to help it complete its task.</p>"},{"location":"glossary/#rayagentproxy","title":"<code>RayAgentProxy</code>","text":"<p>A distributed processing system that can be used as an alternative runtime engine for agents.</p>"},{"location":"glossary/#react-agent","title":"ReAct Agent","text":"<p>The default pattern for Agentic agents, which follows a cycle of Reasoning, taking Action, and observing the result.</p>"},{"location":"glossary/#resumewithinput","title":"<code>ResumeWithInput</code>","text":"<p>An event sent to an agent to continue processing after a pause for human input.</p>"},{"location":"glossary/#run","title":"Run","text":"<p>A single operation request within a thread, representing one full interaction cycle from user prompt to agent response.</p>"},{"location":"glossary/#threadcontext","title":"ThreadContext","text":"<p>An object that holds state during agent execution and provides access to system services, configuration, and secrets.</p>"},{"location":"glossary/#s","title":"S","text":""},{"location":"glossary/#secrets","title":"Secrets","text":"<p>Encrypted credentials stored in a local database that agents can use to access external services.</p>"},{"location":"glossary/#sequential-thinking","title":"Sequential Thinking","text":"<p>A mode where an agent breaks down complex reasoning into explicit steps.</p>"},{"location":"glossary/#sqlite","title":"SQLite","text":"<p>A lightweight, serverless, self-contained database engine that Agentic uses for various storage needs. In the Agentic framework, SQLite is used to store encrypted secrets (in ~/.agentic) and run logs (in ./runtime). Unlike client-server database systems, SQLite reads and writes directly to ordinary disk files without requiring a separate server process. SQLite docs</p>"},{"location":"glossary/#system-prompt","title":"System Prompt","text":"<p>The instructions provided to the LLM that guide the agent's behavior and purpose, set through the instructions parameter.</p>"},{"location":"glossary/#t","title":"T","text":""},{"location":"glossary/#thread","title":"Thread","text":"<p>A persistent conversation with an agent that maintains a history of runs. They can be thought of as a conversation, with multiple user / agent interactions.</p>"},{"location":"glossary/#token","title":"Token","text":"<p>The basic unit of text processing in LLMs. Tokens are fragments of words or characters that the model processes - typically a token is about 4 characters or 3/4 of a word in English. The number of tokens affects both the cost of using LLMs (as providers typically charge per token) and the context window size (maximum input+output length). In Agentic, token usage is tracked and displayed during agent runs to help monitor costs and performance.</p>"},{"location":"glossary/#tool","title":"Tool","text":"<p>A function or capability that allows an agent to interact with the world, query data, or take actions. Tools are the AI-to-computer interface and are the core value added to agents along with instructions.</p>"},{"location":"glossary/#tool-library","title":"Tool Library","text":"<p>A collection of pre-built tools provided by Agentic that agents can use for common tasks like web browsing, database access, API calls, etc.</p>"},{"location":"glossary/#turnend","title":"TurnEnd","text":"<p>An event marking the completion of an agent's processing for a particular run.</p>"},{"location":"glossary/#v","title":"V","text":""},{"location":"glossary/#vector-database","title":"Vector Database","text":"<p>A database optimized for storing and retrieving vector embeddings, used in RAG systems to match queries with relevant document chunks.</p>"},{"location":"glossary/#w","title":"W","text":""},{"location":"glossary/#waitforinput","title":"<code>WaitForInput</code>","text":"<p>An event emitted when an agent needs human input to continue processing.</p>"},{"location":"glossary/#weaviate","title":"Weaviate","text":"<p>The vector database used by Agentic for implementing RAG features.  Weaviate docs</p>"},{"location":"glossary/#welcome-message","title":"Welcome Message","text":"<p>A string displayed to end users when they first interact with an agent, helping them understand its purpose.</p>"},{"location":"planning-agents/","title":"Planning Agents","text":"<p>A \"plan and execute\" agent runs an explicit planning step. This step generates a plan of execution, which is then processed</p>"},{"location":"rag-support/","title":"RAG Support","text":"<p>Agentic has a basic RAG feature set built on the Weaviate vector database.</p> <p>You can manage vectorstore indexes using the CLI:</p> <pre><code># Chunk a file, calculate chunk embeddings, and add them to the vectorstore\nagentic index document add &lt;index name&gt; &lt;file path&gt;\n\n# Remove all the chunks of a file from the vector store\nagentic index document delete &lt;index name&gt; &lt;file path|document ID&gt;\n\n# list the indexes\nagentic index list\n\n# rename an index\nagentic index rename &lt;from name&gt; &lt;to name&gt;\n\n# delete a whole index\nagentic index delete &lt;index name&gt;\n\n# List the documents in a vector store\nagentic index document list &lt;index name&gt;\n\n# Show the metadata for a doc in the vector store\nagentic index document show &lt;index name&gt; &lt;file path|document ID&gt;\n\n# Perform a search of the vector store. Searches by vector by default, or can do hybrid search\nagentic index search &lt;index name&gt; &lt;query&gt; [--hybrid]\n</code></pre> <p>Example usage:</p> <pre><code>$ agentic index document add index1 tests/data/agentic_reasoning.pdf\n\n$ agentic index document list index1\n                                                         Documents in 'index1' (3)                                                         \n- agentic_reasoning.pdf \n  ID: 27c0600f... | Chunks: 19 | Last indexed: 2025-02-22 05:54:51+00:00\n\n$ agentic index search index1 \"reasoning models\"\n                                                     Result 1 - agentic_reasoning.pdf                                                      \n- Source: None\n- Date: 2025-02-22 05:54:51+00:00\n- Distance: 0.18599754571914673\n- Score: N/A\n...\n</code></pre> <p>And to use RAG with an agent, via agentic RAG, just enable the RAG Tool:</p> <pre><code>from agentic.tools import MCPTool, RAGTool\nfrom agentic.common import Agent\n\n# Create Sequential Thinking MCP tool\nsequential_thinker = MCPTool(\n    command=\"npx\",\n    args=[\"-y\", \"@modelcontextprotocol/server-sequential-thinking\"]\n)\n\nagent=Agent(\n    name=\"Agent with RAG\",\n    tools=[\n        RAGTool(\"index1\"),\n        sequential_thinker\n    ]\n)\nprint(agent &lt;&lt; \"What do we know about reasoning models?\")\n</code></pre> <p>Coming soon: Classic RAG</p> <p>Create an agent which programmatically loads content from RAG into the LLM context to answer the user's query.</p>"},{"location":"building-agents/","title":"Building Agents","text":""},{"location":"building-agents/#terminology","title":"Terminology","text":"<p>An \"agent\" is an LLM-powered program that is defined in code. </p> <p>The persistent history of your interactions with an agent consitute a thread. The LLM context is preserved as long as the thread session continues. Once a new Thread is started then the context goes back to the initial state.</p> <p>Each interaction of: user request -&gt; agent thinking -&gt; agent response is called a run. A single thread can include many runs. </p> <p>As your agent operates, it may take multiple steps in order to complete a run. Generally each step will result in either a completion - the generation of some text, or a function call, or both together. Tracing the steps of your agent inside of a run is done by reviewing the logs generated by the agent.</p> <p>Construct an Agent like this:</p> <pre><code>from agentic.common import Agent\n\ndef weather_tool():\n    return \"The weather is nice today.\"\n\n\nagent = Agent(\n    name=\"Basic Agent\",\n    welcome=\"I am a simple agent here to help answer your weather questions.\",\n    instructions=\"You are a helpful assistant.\",\n    model=\"openai/gpt-4o-mini\",\n    tools=[WeatherTool()],\n)\n</code></pre> <p>The <code>instructions</code> set the \"system prompt\" for the LLM. The \"welcome message\" is just a string that can be displayed to the end user to help them use the agent.</p> <p>Optional parameters to your agent include:</p> <pre><code>max_tokens - The maximum number of tokens to generate on each completion\nmemories - A list of facts to inject into the Agent's context for every Run\n</code></pre> <p>See models for information on using different models. </p> <p>See tools for information on creating and using tools.</p>"},{"location":"building-agents/#secrets","title":"Secrets","text":"<p>When your agent runs it will likely need api keys for various services. You can set these keys in your environment, but this approach gets very unwieldy with lots of keys.</p> <p>Agentic includes a simple system for managing <code>secrets</code>. They are stored encrypted in a local SQLite database file (inside <code>~/.agentic</code>).</p> <pre><code>agentic secrets list   - list your secrets\n\nagentic secrets set &lt;secret name&gt;=&lt;value&gt;\nagentic secrets get &lt;secret name&gt;\n</code></pre> <p>All secrets are automatically injected into the environment when your agent runs, but it is recommended to get values from the <code>ThreadContext</code> using <code>get_config</code> and <code>get_secret</code>. One nice feature is that secrets can be stored in a <code>namespace</code> named after your agent, so that you can manage multiple values across different agents.</p>"},{"location":"building-agents/#using-agentrunner-and-the-repl","title":"Using AgentRunner and the REPL","text":"<p>The <code>AgentRunner</code> class is a convenience utility for running a repl to interact with your agent:</p> <pre><code>from agentic.common import Agent, AgentRunner\n\nagent = Agent(...)\n\nif __name__ == 'main':\n    AgentRunner(agent).run_repl()\n</code></pre> <p>By default it maintains a persistent Thread (session) with your agent, so that each turn is appending to the active thread. </p> <pre><code>% python examples/basic_agent.py \nI am a simple agent here to help answer your weather questions.\n\n[Basic Agent]&gt; my name is scott\nHello, Scott! How can I assist you today?\n[Basic Agent]&gt; what is my name ?\nYour name is Scott.\n[openai/gpt-4o-mini: 1 calls, tokens: 12 -&gt; 5, 0.00 cents, time: 0.73s tc: 0.00 c, ctx: 40]\n</code></pre> <p>The runner repl includes a set of \"dot\" system commands:</p> <pre><code>&gt; .help\n\n    .agent - Show the state of the active agent\n    .run &lt;agent name&gt; - switch the active agent\n    .history - show the history of the current session\n    .debug [&lt;level&gt;] - enable debug. Defaults to 'tools', or one of 'llm', 'tools', 'all', 'off'\n    .settings - show the current config settings\n    .model - switch the active LLM model\n    .help - Show this help\n    .quit - Quit the REPL\n</code></pre> <p>Examples:</p> <pre><code>[Basic Agent]&gt; .agent\nBasic Agent\nYou are a helpful assistant.\ntools:\n  WeatherTool\n</code></pre> <p>The .debug command is especially helpful to activate different kinds of tracing:</p> <pre><code>.debug tools    - Shows logging for tool start/finish events\n.debug llm      - Shows all LLM completion calls\n.debug agents   - Only log events where an agent starts a run\n.debug all      - Logs everything\n</code></pre> <p>We often run with <code>.debug tools</code> to track what our agents are doing. You can also set the debug value via the <code>AGENTIC_DEBUG</code> env var.</p>"},{"location":"building-agents/#things-to-note","title":"Things to note","text":"<p>We have used the convenience <code>repl_loop</code> in <code>AgentRunner</code> to interface to our agent. But we can write our own loop (or API or whatever) to run our agent:</p> <pre><code>while True:\n    prompt = input(\"&gt; \")\n    request_id = agent.start_request(prompt).request_id\n\n    for event in agent.get_events(request_id):\n        print(\"Agent event: \", event)\n</code></pre> <p>The <code>get_events</code> function will keep emitting events until the current run of the agent is complete. We can loop again and let the user request another task from the agent.</p> <p>Because you are getting fine-grained events as the agent runs, you can choose to do other things in the middle, including things like modifying the agent by giving it more tools. Even though this interface looks like the agent is \"running\" some thread (like in Langchain), in fact the agent runs step by step, generating events along the way, but it can stop at any time.</p>"},{"location":"building-agents/#next-steps","title":"Next steps","text":"<ul> <li>See more about events.</li> <li>Learn about the CLI</li> <li>Learn how to use and build Tools for your agent</li> <li>Discover some example agents.</li> <li>Learn about Agent Teams.</li> </ul>"},{"location":"building-agents/advanced-custom-agents/","title":"Advanced Agent Configuration","text":"<p>This document explains how to implement your own agent using a custom <code>next_turn</code> method in the Agentic framework. It covers the use cases, benefits, tradeoffs, and best practices to follow.</p>"},{"location":"building-agents/advanced-custom-agents/#why-customize-next_turn","title":"Why Customize <code>next_turn</code>?","text":"<p>The <code>next_turn</code> method is the core orchestration loop for an agent in Agentic. Overriding it gives you control over:</p> <ul> <li>How your agent interacts with subagents.</li> <li>How tools are invoked.</li> <li>The logic for multi-step workflows (e.g., retries, research-plan-execute loops).</li> <li>Waiting for user feedback or pausing between steps.</li> </ul>"},{"location":"building-agents/advanced-custom-agents/#example-use-case","title":"Example Use Case","text":"<p>Our Open Source Deep Research agent uses a custom <code>next_turn</code> to orchestrate a multi-step workflow:</p> <p>Research planning \u2192 Human validation \u2192 Knowledge accumulation \u2192 Section writing \u2192 Final report assembly.</p> <p>This approach allows for iterative refinement and human-in-the-loop validation, making it suitable for complex research tasks. Each step along the way has its own subagent. The custom <code>next_turn</code> method calls the subagents and orchestrates the overall workflow.</p> <p>Note: This workflow supports human-in-the-loop validation, where the agent pauses after an initial plan generation to wait for user feedback before continuing to allow for iterative refinement.</p>"},{"location":"building-agents/advanced-custom-agents/#pros-of-writing-a-custom-next_turn","title":"Pros of Writing a Custom <code>next_turn</code>","text":"Benefit Explanation Full control over agent logic Define exactly how the workflow runs step-by-step. Conditional logic Branch based on intermediate results (e.g., \"if feedback is bad, retry\"). Hierarchical coordination Easily manage subagents and tools. Better custom observability Yield concise <code>Event</code>s for custom logging and monitoring."},{"location":"building-agents/advanced-custom-agents/#cons-and-tradeoffs","title":"Cons and Tradeoffs","text":"Challenge Impact More boilerplate You'll have to manage event yielding manually and accurately for the agent to run correctly Less plug-and-play Higher learning curve than basic function-based tools. Error-prone in async contexts Use generators properly and be careful with subagent calls that are also generators."},{"location":"building-agents/advanced-custom-agents/#best-practices","title":"Best Practices","text":""},{"location":"building-agents/advanced-custom-agents/#1-always-yield-promptstarted-first","title":"1. Always Yield <code>PromptStarted</code> First","text":"<pre><code>yield PromptStarted(self.name, {\"content\": self.topic})\n</code></pre>"},{"location":"building-agents/advanced-custom-agents/#2-use-waitforinput-for-pauses","title":"2. Use <code>WaitForInput</code> for Pauses","text":"<pre><code>yield WaitForInput(self.name, {\"feedback\": \"Please provide feedback on the plan.\"})\nreturn  # Safely exit the generator after yielding pause\n</code></pre>"},{"location":"building-agents/advanced-custom-agents/#3-subagent-calls-should-use-yield-from","title":"3. Subagent Calls Should Use <code>yield from</code>","text":"<pre><code>queries = yield from self.query_planner.final_result(\"Generate queries\", request_context={...})\n</code></pre>"},{"location":"building-agents/advanced-custom-agents/#4-always-finish-with-a-turnend-event","title":"4. Always finish with a <code>TurnEnd</code> event","text":"<pre><code>yield TurnEnd(self.name, {\"status\": \"Turn completed.\"})\n</code></pre> <p>This ensures that:</p> <ul> <li>Events from the subagent are streamed properly.</li> <li>Subagent run tracking remains isolated.</li> <li>The turn is ended properly.</li> </ul>"},{"location":"building-agents/advanced-custom-agents/#subagent-thread_id-propagation-for-subagents","title":"Subagent <code>thread_id</code> Propagation for Subagents","text":"<p>To ensure events from subagents (like planners or tools) are grouped with the top-level agent in the event-logs, you must pass thread_id in request_context and ensure it is picked up by the subagent. </p>"},{"location":"building-agents/advanced-custom-agents/#what-to-do","title":"What to do","text":"<p>pass <code>thread_id</code> in every subagent request:</p> <pre><code>result = yield from self.section_planner.final_result(\n    \"Plan sections\",\n    request_context={\n        \"topic\": self.topic,\n        \"thread_id\": thread_context.thread_id  # Required for shared logging\n    }\n)\n</code></pre>"},{"location":"building-agents/advanced-custom-agents/#event-flow-cheat-sheet","title":"Event Flow Cheat Sheet","text":"Event Type Purpose <code>PromptStarted</code> Start of a turn, log the prompt. <code>ChatOutput</code> Message from agent or subagent. <code>ToolCall</code> / <code>ToolResult</code> Tool usage events. <code>WaitForInput</code> Pauses until user input. <code>TurnEnd</code> Signals end of a turn + final result."},{"location":"building-agents/advanced-custom-agents/#minimal-example-of-custom-next_turn","title":"Minimal Example of Custom <code>next_turn</code>","text":"<pre><code>def next_turn(self, request: str | Prompt, request_context: dict = {}, **kwargs):\n    topic = request.payload if isinstance(request, Prompt) else request\n    yield PromptStarted(self.name, {\"content\": topic})\n\n    # Example: Plan \u2192 Research \u2192 Write\n    plan = yield from self.planner_agent.final_result(\n        \"Make a plan\", \n        request_context={\"topic\": topic, \"thread_id\": request_context.get(\"thread_id\")}\n    )\n\n    yield ChatOutput(self.name, {\"content\": f\"Plan: {plan}\"})\n\n    yield WaitForInput(self.name, {\"feedback\": \"Approve the plan or provide feedback.\"})\n    yield TurnEnd(self.name, {\"status\": \"Turn completed after waiting for input.\"})\n</code></pre>"},{"location":"building-agents/advanced-custom-agents/#key-things-to-avoid","title":"Key Things to Avoid","text":"<ul> <li>Don\u2019t return early without yielding <code>TurnEnd</code>.</li> <li>Don\u2019t mix sync calls and generator calls (<code>yield from</code>) improperly.</li> <li>Don\u2019t directly call subagent methods like <code>.next_turn()</code> \u2014 use the proxy API (<code>final_result</code>, etc.).</li> </ul>"},{"location":"building-agents/advanced-custom-agents/#api-expectations","title":"API Expectations","text":"Concept Expectation <code>thread_id</code> Must be consistent per top-level request. Logging Only logs events for current agent, unless propagating via shared <code>thread_id</code> History Cleanly reset between runs if your agent doesn't need memory."},{"location":"building-agents/advanced-custom-agents/#example-use-cases","title":"Example Use Cases","text":"<ul> <li>Multi-agent research assistants (planner \u2192 researcher \u2192 writer).</li> <li>Interactive approval workflows (wait for feedback before proceeding).</li> <li>Branching agents for complex tasks (e.g., \"if else logic\").</li> </ul>"},{"location":"building-agents/agent-teams/","title":"Agent Teams","text":"<p>Agentic makes it very easy to solve a larger problem using a team of agents which collaborate together.</p> <p>The easiest mechanism is to employ one agent as a tool for another agent:</p> <pre><code>producer = Agent(\n    name=\"producer\",\n    instructions=\"You are a podcast producer. Call your reporter to get the news report.\",\n    tools=[\n        Agent(\n            name=\"reporter\",\n            instructions=\"You are a hard news reporter.\",\n            tools=[GoogleNewsTool()]\n        )\n    ]\n)\n</code></pre> <p>The producer agent will receive a tool function like <code>call_reporter_agent</code> which it can call to invoke the reporter agent.</p> <p>You can attach multiple agents as tools to another agents, and there is no depth limit, so sub-agents can invoke other sub-agents as needed.</p>"},{"location":"building-agents/agent-teams/#using-in-a-workflow-agent","title":"Using in a workflow agent","text":"<p>You can always write your own code to implement your agent flow (by subclassing <code>Agent</code>), and  in this case you can call sub-agents programatically. The Deep Research example agent  uses this approach extensively to coordinate a large team of special-purpose agents.  A good pattern for calling sub-agents looks like this:</p> <pre><code>    def next_turn(self):\n        self.sub_agent = Agent(...)\n        result = yield from self.sub_agent.final_result(\n                \"Please query the order system.\",\n                request_context={\n                    \"order_id\": order_id, \n                },\n            )\n        # do something with 'result'\n</code></pre> <p>There are two tricks here. The first is calling <code>final_result</code> which waits for the end of the agent run and returns the final text output. The other trick is the <code>yield from</code> which re-publishes any events that the sub-agent produces before it completes.</p>"},{"location":"building-agents/agent-teams/#when-should-i-use-agent-teams","title":"When should I use agent teams?","text":"<p>One obvious use for sub-agents is when you already have an agent which performs some valuable task, and you just want to leverage that task from another agent. Now you could go look at the other agent, see what tools it is using, and use those tools directly in your agent. This is fine, but calling a sub-agent offers some benefits:</p> <ul> <li> <p>Sub-agents can use their own LLM, which could be a different model than the one powering the calling agent. This is good if your sub-task requires some capability that your main model doesn't offer (or to arbitrage model costs).</p> </li> <li> <p>Sub-agents can leverage the LLM for reasoning and decision making. As a simple example, we could give our reporter agent multiple \"news feed\" tools and let it decide which ones to  use as appropriate. </p> </li> <li> <p>Sub-agents let you mange your overall LLM context. Context windows are limited, tokens cost money, and LLM decision making gets less reliable as the context size grows. All of these factors create reasons for wanting to \"split your problem\" across multiple agents.</p> </li> </ul>"},{"location":"building-agents/agent-teams/#unified-event-stream","title":"Unified event stream","text":"<p>Note that when Agent A calls Agent B in the agentic framework, both agents are operating within a shared Thread. This means that events published by both agents will appear in the same event stream to the agent caller. Events identify their source agent and depth, so client apps (like a web interface) can decide how to render \"nested\" events within the overall thread.</p>"},{"location":"building-agents/debugging/","title":"Debugging","text":"<p>The simplest tools for debugging are using the debug levels in the REPL:</p> <pre><code>'agents' - Log agent operations\n'tools'  - Log all tool calls\n'llm'    - Log LLM completions\n'all'    - Log everything\n</code></pre> <p>Note that you can also combine tags like 'tools,llm':</p> <pre><code>&gt; .debug tools,llm\nDebug level set to: tools,llm\n</code></pre> <p>You can also set the debug level via the <code>AGENTIC_DEBUG</code> env var:</p> <pre><code>export AGENTIC_DEBUG=tools\n</code></pre> <p>Switching models</p> <p>Use <code>.model &lt;model&gt;</code> to temporarily change the active model of the current agent:</p> <pre><code>[Basic Agent]&gt; .model claude-3-opus-20240229\nModel set to claude-3-opus-20240229\n[Basic Agent]&gt; when is your training ?\n&lt;thinking&gt;\nThe user is asking when my training occurred. This question does not require any of the provided weather-related tools to answer. The tools are for retrieving current weather, weather forecasts, historical weather data, and historical weather averages for specific locations and dates. None of them are relevant for providing information about my own training.\n&lt;/thinking&gt;\n\nI do not have specific information about when I was trained. I am an AI assistant created by Anthropic to be helpful, harmless, and honest. The details of my training process are not something I have direct knowledge of.\n[claude-3-opus-20240229: 1 calls, tokens: 12 -&gt; 113, 2.98 cents, time: 5.17s tc: 2.98 c, ctx: 125]\n</code></pre> <p>Showing chat messages</p> <p>Use <code>.history</code> to see the list of Messages in the current LLM context.</p>"},{"location":"core-concepts/","title":"Core Concepts","text":"<p>This page explains the fundamental concepts behind Agentic's design and operation.</p>"},{"location":"core-concepts/#understanding-agents","title":"Understanding Agents","text":"<p>Agentic agents by default use the LLM ReAct pattern. This means:</p> <ul> <li>The LLM controls the execution flow of your agent</li> <li>You specify the tasks and flow of your agent via the LLM system prompt</li> <li>The agent gets one or more tools that it can use to accomplish its task</li> <li>The agent runs in this loop until it decides that it can't go further:<ul> <li>plan next step</li> <li>generate text completion or tool call     (platform executes tool call)</li> <li>observe tool call results</li> </ul> </li> </ul>"},{"location":"core-concepts/#components-of-an-agent","title":"Components of an Agent","text":"<p>An agent is defined by its behavior - what it does as perceived from the outside. But inside, each agent has these properties:</p> <ul> <li>name: A unique identifier for the agent</li> <li>instructions: The system prompt that guides the agent's behavior</li> <li>tools: Functions the agent can use to interact with the world</li> <li>children agents: Sub-agents that can be called as tools</li> <li>model: The chosen LLM model</li> <li>welcome (optional): A message explaining the purpose of the agent</li> <li>memories (optional): A list of memories the agent uses during execution</li> <li>prompts (optional): A list of pre-defined prompts that can be called</li> </ul>"},{"location":"core-concepts/#data-model","title":"Data Model","text":"<p>The Agentic framework uses the following key concepts:</p> <ul> <li>Agent: A named unit of execution that supports operations and maintains state</li> <li>Thread: A persistent conversation with an agent that maintains history</li> <li>Run: A single operation request within a thread</li> <li>Event: Data emitted during a run (output, tool calls, etc.)</li> </ul>"},{"location":"core-concepts/#agents-as-a-team","title":"Agents as a Team","text":"<p>Agents can call other agents as tools, allowing you to create teams of cooperating agents.</p> <pre><code>from agentic.tools import GoogleNewsTool\n\nproducer = Agent(\n    name=\"Producer\",\n    welcome=\"I am the news producer. Tell me the topic, and I'll get the news from my reporter.\",\n    instructions=\"You are a news producer. Call the reporter with the indicated topic.\",\n    model=\"gpt-4o-mini\",\n    tools=[\n        Agent(\n            name=\"News Reporter\",\n            instructions=f\"\"\"\n        Call Google News to get headlines on the indicated news topic.\n        \"\"\",\n            tools=[GoogleNewsTool()],\n        )\n    ],\n)\n</code></pre>"},{"location":"core-concepts/#agent-handoff","title":"Agent Handoff","text":"<p>Sometimes you want to \"hand off\" execution to another agent rather than waiting for it to return. Use the <code>handoff</code> property for this:</p> <pre><code>from agentic import handoff\n\nagentA = Agent(\n    name=\"Producer\",\n    welcome=\"This is the handoff demo.\",\n    instructions=\"Print the message 'I am A', then call agent B. Afterwards print 'WARNING!'\",\n    tools=[\n        handoff(Agent(\n            name=\"Agent B\",\n            instructions=\"Print the msssage 'and I am B'\",\n        ))\n    ],\n)\n</code></pre> <p>Without using <code>handoff</code>, the WARNING message would be printed from the root agent. Handoff is useful if your sub-agent generates a lot of output, because normally that output would be fed back into AgentA as the <code>observation</code> step.</p>"},{"location":"core-concepts/#agent-memory","title":"Agent Memory","text":"<p>Agents support multiple types of memory:</p> <ul> <li>Short-term memory: The chat session history in the agent's context window</li> <li>Persistent facts: Data stored anywhere and applied to the agent context when it runs</li> <li>Run history: Persistence of chat sessions for later review</li> <li>RAG memory: Vector storage for larger-than-context retrieval of information</li> </ul>"},{"location":"core-concepts/#event-system","title":"Event System","text":"<p>As agents run, they emit events that can be observed and processed:</p> <ul> <li><code>ChatOutput</code>: Text generated by the LLM</li> <li><code>ToolResult</code>: Results of tool calls</li> <li><code>PromptStarted</code> and <code>TurnEnd</code>: Lifecycle events</li> <li><code>FinishCompletion</code>: Token usage and tracking data</li> </ul> <p>Events have a <code>depth</code> attribute indicating which level of agent generated them, allowing UIs to filter appropriately.</p> <p>For more information, see the Events documentation.</p>"},{"location":"core-concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Learn how to Build Agents</li> <li>Understand how to use and create Tools</li> <li>Explore Agent Teams</li> <li>See the CLI Reference</li> <li>Check out Examples</li> </ul>"},{"location":"core-concepts/agentic-design-principles/","title":"Agentic Design Principles","text":""},{"location":"core-concepts/agentic-design-principles/#1-an-agentic-system-should-leverage-the-llm-as-much-as-possible","title":"1. An agentic system should leverage the LLM as much as possible.","text":"<p>As much as possible an agentic app leverages the planning and reasoning of the LLM. Most logic should happen at inference-time rather than compile-time.</p>"},{"location":"core-concepts/agentic-design-principles/#2-the-probabilistic-nature-of-llm-inference-is-a-feature","title":"2. The probabilistic nature of LLM inference is a feature","text":"<p>Traditional software strives for perfectly deterministic behavior. But the probabilitic nature of the LLM gives us the ability to write software which is creative, reflective and self-improving. Many systems will need guardrails and self-healing logic to ensure reliable operation, but trying to get perfect determinism from an agent is misguided.</p>"},{"location":"core-concepts/agentic-design-principles/#3-agents-follow-the-actor-model","title":"3. Agents follow the actor model","text":"<p>Agents should follow the actor model from computer science, which means: - They are encapsulated programs which can only manipulate their own private state - They are event driven, responding to messages and generating messages</p>"},{"location":"core-concepts/agentic-design-principles/#4-tools-as-agents","title":"4. Tools as agents","text":"<p>It is common to want to apply function calling semantics to LLM programs, which is encouraged by OpenAI's function calling API. But function calling is the wrong paradigm for agents since it generally implies synchronous execution and strictly typed parameters. Both of these are poor assumptions when building AI agents.</p> <p>Rather than generalize everything as a function call, it is better to generalize everything as an actor (agent). So doing a \"web search\" call means sending a message event to the \"web search agent\", which will reply with events containing the results. We can easily implement this as a compile-time tool, but it also means that our \"web search tool\" could just as easily be another full agent.</p>"},{"location":"core-concepts/agentic-design-principles/#5-the-best-tool-protocols-are-languages","title":"5. The best tool protocols are languages","text":"<p>LLMs are really good at language, which implies that the best way to interface them into traditional systems is via some protocol language, rather than describing some huge set of REST endpoints. Wherever possible try to build tools on top of language protocols like SQL or GraphQL, where the LLM can express complex operations very efficiently. If your system doesn't support a language already known to your model, you can define a new language and teach it to your agent. </p>"},{"location":"core-concepts/agentic-design-principles/#agent-trust","title":"Agent Trust","text":""},{"location":"core-concepts/agentic-design-principles/#6-an-agent-must-be-trusted-by-humans-or-it-will-have-no-value","title":"6. An agent must be trusted by humans, or it will have no value","text":"<p>AI agents will not, and should not, be trusted by default. They have to earn trust. These guidelines are a starting point for building trustworthy agents. The key elements of trust include:     - the agent will only perform expected operations     - the behavior of the agent is explainable     - the agent will rely only on knowledge we expect it to use, and it will         explain its knowledge sources when it makes a decision     - the agent stays aligned with its operator's values, and the values of         human safety</p>"},{"location":"core-concepts/agentic-design-principles/#7-agents-must-only-run-under-the-authority-of-a-named-human-user","title":"7. Agents must only run under the authority of a named human user","text":"<p>Agents always inherit their authority to access information or resources from their human creators and operators.  Agents must never run autonomously  without any human being named as responsible for their operation.  Allowing anonymous (or \"AI identity\") operation is a dangerous anti-pattern. </p> <p>Human in the loop is a key feature that agents should rely on until they can prove that they can operate autonomously.</p>"},{"location":"core-concepts/agentic-design-principles/#8-agent-behavior-must-be-explainable","title":"8. Agent behavior must be explainable","text":"<p>We cannot necessarily predict agent behavior, but agentic systems must explain what they are doing and why as much as possible. Unexplainable behavior is a system bug to be fixed, and should not be tolerated. Part of explainability is transparency about the operations executed and resources used by the agent.</p> <p>Agent User Interface should always promote and provide explainability - they should never hide the actions of the agent.</p>"},{"location":"core-concepts/agentic-design-principles/#9-agents-should-come-with-test-contracts","title":"9. Agents should come with test contracts","text":"<p>Test Contracts are a way of automatically testing for the correct behavior of your agent. These are critical to building reliable agentic systems, especially ones that run</p>"},{"location":"core-concepts/event-system/","title":"Event System","text":"<p>The agent protocol defines a set of events which are emitted when an agent is processing an operation.</p> <p>The most obvious events are <code>ChatOutput</code> events which represent text generations from the LLM. </p> <p>To show tool calls, you should show <code>ToolResult</code> events.</p> <p>To understand the lifecycle of processing you can observe <code>PromptStarted</code> and <code>TurnEnd</code> events. </p> <p>To track usage you should process <code>FinishCompletion</code> events which will contain token usage data.</p>"},{"location":"core-concepts/event-system/#event-depth","title":"Event depth","text":"<p>Events have a <code>depth</code> attribute which indicates how deep is the agent that is generating the event. So the top agent generates <code>depth=0</code>, the first level  sub-agent generates at <code>depth=1</code> and so forth. </p> <p>Observing depth allows you to build a UI that surfaces the right level of detail to the user. The simplest UI should only expose ChatOutput events with <code>depth=0</code>, because these are LLM generations from the top-level agent. </p>"},{"location":"core-concepts/event-system/#event-data-flow","title":"Event data flow","text":"<p>Agents publish events whenever they are asked to do something. For a single agent this mechanism is simple:</p> <pre><code>caller      --- msg --&gt;     agent\n  |                           |\n  |         &lt;-- event ---     |\n</code></pre> <p>However, once agents start calling other agents, it gets more complicated. Our general rules is that ALL events published at any level should bubble up back to the original caller. This is to maximize the caller's visibility into what the system is doing:</p> <pre><code>caller      --- msg --&gt;     agent A               agent B\n  |                           |                       |\n  |         &lt;-- event1 ---    |                       |\n  |                           |    --- call B -&gt;      |\n  |                           |                       |\n  |                           |     &lt;-- event 2 --    |\n  |         &lt;-- event 2 ---   |                       |\n</code></pre> <p>Each event has an agent <code>name</code> property, and <code>depth</code> property which indicates how far down  in the call tree the event originated.</p> <p>So the caller will get these two events:</p> <pre><code>event1 (Agent A, depth=0)\nevent2 (Agent B, depth=1)\n</code></pre> <p>This allows the caller to ignore sub-agent execution if it prefers.</p>"},{"location":"core-concepts/event-system/#agent-execution-flow","title":"Agent execution flow","text":"<p>When you call agent A, it may execute agent B, plus agent C, and they in turn may call other agents.</p> <p>If you want to observe all events from the entire execution tree, then you should implement logic to record the recept of events from each distinct agent, and then make sure to wait for the <code>TurnEnd</code> message from each one. </p>"},{"location":"core-concepts/event-system/#agent-pipeline","title":"Agent pipeline","text":"<p>To implement \"pipeline semantics\", agents can \"hand off\" from one to another. In this case the sub-agent will assume the original caller of the first agent, and will assume its <code>depth</code> as well:</p> <pre><code>caller      --- msg --&gt;     agent A               agent B\n  |                           |                       |\n  |         &lt;-- event1 ---    |                       |\n  |                           |  ---  *handoff* B -&gt;  |\n  |         &lt;-- turnend: A -- |                       |                \n  |                                                   |\n  |         &lt;-- ---------------------- event 2 --     |\n</code></pre> <p>So the caller will get events like this:</p> <pre><code>event1 (Agent A, depth=0)\nevent2 (Agent B, depth=0)\n</code></pre>"},{"location":"core-concepts/event-system/#chat-history","title":"Chat history","text":"<p>A typical interactive agent is built with chat history which maintains the history of interactions over the life of a session.</p>"},{"location":"core-concepts/event-types/","title":"Event Types","text":""},{"location":"core-concepts/event-types/#base-event","title":"Base Event","text":"<p>All events derive from the base <code>Event</code> class, which has these common properties:</p> <ul> <li><code>agent</code>: The name of the agent that generated the event</li> <li><code>type</code>: The type of the event (e.g., \"prompt\", \"chat_output\")</li> <li><code>payload</code>: The data associated with the event</li> <li><code>depth</code>: The nesting level (0 for top-level agent, 1+ for sub-agents)</li> </ul>"},{"location":"core-concepts/event-types/#communication-events","title":"Communication Events","text":""},{"location":"core-concepts/event-types/#prompt","title":"Prompt","text":"<p>Represents a request sent to an agent to perform an operation.</p> <pre><code>Prompt(\n    agent=\"my_agent\",\n    message=\"What's the weather like today?\",\n    debug=DebugLevel.NONE,\n    request_context={},  # Optional context data\n    depth=0,  # Level in agent hierarchy\n    ignore_result=False,  # Whether to ignore the result\n    request_id=None  # Optional request ID (auto-generated if None)\n)\n</code></pre>"},{"location":"core-concepts/event-types/#promptstarted","title":"PromptStarted","text":"<p>Signals that an agent has started processing a prompt.</p> <pre><code>PromptStarted(\n    agent=\"my_agent\",\n    message=\"What's the weather like today?\",\n    depth=0\n)\n</code></pre>"},{"location":"core-concepts/event-types/#resethistory","title":"ResetHistory","text":"<p>Indicates that an agent's conversation history has been reset.</p> <pre><code>ResetHistory(agent=\"my_agent\")\n</code></pre>"},{"location":"core-concepts/event-types/#chatoutput","title":"ChatOutput","text":"<p>Output containing a chat message.</p> <pre><code>ChatOutput(\n    agent=\"my_agent\",\n    payload={\"content\": \"This is a response\", \"role\": \"assistant\"},\n    depth=0\n)\n</code></pre>"},{"location":"core-concepts/event-types/#turnend","title":"TurnEnd","text":"<p>Signals the completion of an agent's processing for a run.</p> <pre><code>TurnEnd(\n    agent=\"my_agent\",\n    messages=[{\"role\": \"assistant\", \"content\": \"Final response\"}],\n    thread_context=thread_context_obj,\n    depth=0\n)\n</code></pre>"},{"location":"core-concepts/event-types/#turncancelled","title":"TurnCancelled","text":"<p>Indicates that an agent's run was cancelled.</p> <pre><code>TurnCancelled(agent=\"my_agent\", depth=0)\n</code></pre>"},{"location":"core-concepts/event-types/#tool-related-events","title":"Tool-Related Events","text":""},{"location":"core-concepts/event-types/#toolcall","title":"ToolCall","text":"<p>Represents an agent calling a tool with arguments.</p> <pre><code>ToolCall(\n    agent=\"my_agent\",\n    name=\"weather_tool\",\n    arguments={\"location\": \"New York\"},\n    depth=0\n)\n</code></pre>"},{"location":"core-concepts/event-types/#toolresult","title":"ToolResult","text":"<p>Contains the result returned from a tool call.</p> <pre><code>ToolResult(\n    agent=\"my_agent\",\n    name=\"weather_tool\",\n    result=\"It's 75\u00b0F and sunny in New York\",\n    depth=0\n)\n</code></pre>"},{"location":"core-concepts/event-types/#toolerror","title":"ToolError","text":"<p>Represents an error that occurred during a tool call.</p> <pre><code>ToolError(\n    agent=\"my_agent\",\n    name=\"weather_tool\",\n    error=\"Failed to retrieve weather data: API timeout\",\n    depth=0\n)\n</code></pre>"},{"location":"core-concepts/event-types/#llm-completion-events","title":"LLM Completion Events","text":""},{"location":"core-concepts/event-types/#startcompletion","title":"StartCompletion","text":"<p>Signals the start of an LLM completion operation.</p> <pre><code>StartCompletion(agent=\"my_agent\", depth=0)\n</code></pre>"},{"location":"core-concepts/event-types/#finishcompletion","title":"FinishCompletion","text":"<p>Contains information about a completed LLM operation, including token usage and cost.</p> <pre><code>FinishCompletion.create(\n    agent=\"my_agent\",\n    llm_message=\"The generated response\",\n    model=\"gpt-4\",\n    cost=0.02,\n    input_tokens=150,\n    output_tokens=50,\n    elapsed_time=1.5,\n    depth=0\n)\n</code></pre>"},{"location":"core-concepts/event-types/#human-in-the-loop-events","title":"Human-in-the-loop Events","text":""},{"location":"core-concepts/event-types/#waitforinput","title":"WaitForInput","text":"<p>Indicates that an agent is waiting for human input to continue.</p> <pre><code>WaitForInput(\n    agent=\"my_agent\",\n    request_keys={\"user_preference\": \"Please specify your preference\"}\n)\n</code></pre>"},{"location":"core-concepts/event-types/#resumewithinput","title":"ResumeWithInput","text":"<p>Sent by the caller with human input to resume an agent's execution.</p> <pre><code>ResumeWithInput(\n    agent=\"my_agent\",\n    request_keys={\"user_preference\": \"Option A\"},\n    request_id=\"abc123\"\n)\n</code></pre>"},{"location":"core-concepts/event-types/#authentication-events","title":"Authentication Events","text":""},{"location":"core-concepts/event-types/#oauthflow","title":"OAuthFlow","text":"<p>Emitted when OAuth authentication is required.</p> <pre><code>OAuthFlow(\n    agent=\"my_agent\",\n    auth_url=\"https://example.com/oauth\",\n    tool_name=\"github_tool\",\n    depth=0\n)\n</code></pre>"},{"location":"core-concepts/event-types/#agent-state-events","title":"Agent State Events","text":""},{"location":"core-concepts/event-types/#setstate","title":"SetState","text":"<p>Used to update an agent's internal state.</p> <pre><code>SetState(agent=\"my_agent\", payload={\"key\": \"value\"}, depth=0)\n</code></pre>"},{"location":"core-concepts/event-types/#addchild","title":"AddChild","text":"<p>Adds a child agent to a parent agent.</p> <pre><code>AddChild(agent=\"parent_agent\", remote_ref=child_agent_ref, handoff=False)\n</code></pre>"},{"location":"core-concepts/event-types/#special-result-types","title":"Special Result Types","text":"<p>These aren't events, but special return values that affect agent flow:</p>"},{"location":"core-concepts/event-types/#pauseforinputresult","title":"PauseForInputResult","text":"<p>Tells the agent to pause and wait for human input.</p> <pre><code>PauseForInputResult(request_keys={\"user_preference\": \"Please specify your preference\"})\n</code></pre>"},{"location":"core-concepts/event-types/#oauthflowresult","title":"OAuthFlowResult","text":"<p>Indicates that OAuth flow needs to be initiated.</p> <pre><code>OAuthFlowResult(request_keys={\"auth_url\": \"https://example.com/oauth\", \"tool_name\": \"github_tool\"})\n</code></pre>"},{"location":"core-concepts/event-types/#finishagentresult","title":"FinishAgentResult","text":"<p>Tells the agent to stop processing entirely.</p> <pre><code>FinishAgentResult()\n</code></pre>"},{"location":"core-concepts/event-types/#event-flow-example","title":"Event Flow Example","text":"<p>A typical event flow for a simple agent interaction might look like:</p> <ol> <li><code>Prompt</code> - User sends a request to the agent</li> <li><code>PromptStarted</code> - Agent begins processing the request</li> <li><code>StartCompletion</code> - Agent starts an LLM completion</li> <li><code>FinishCompletion</code> - LLM generates a response</li> <li><code>ToolCall</code> - Agent decides to use a tool</li> <li><code>ToolResult</code> - Tool returns a result</li> <li><code>StartCompletion</code> - Agent starts another LLM completion</li> <li><code>ChatOutput</code> - Agent returns a text response</li> <li><code>FinishCompletion</code> - LLM generates final response</li> <li><code>TurnEnd</code> - Agent completes processing the request</li> </ol>"},{"location":"core-concepts/introduction-to-agents/","title":"Introduction to Agents","text":""},{"location":"core-concepts/introduction-to-agents/#what-is-an-ai-agent","title":"What is an AI Agent?","text":"<p>An AI agent is a software system that can perceive its environment, make decisions, and take actions to achieve specific goals. Unlike standard AI models that simply respond to inputs with outputs, agents actively interact with their environment in a goal-directed manner. </p> <p>Agents are built on top of large language models (LLMs). This creates a system with the knowledge and power of the base LLM, but also the ability to interact with the outside world. An AI agent can do this with the special abilites (tools) it is given. Tools allow agents to query APIs, search the internet, process images and other media, and so much more.</p>"},{"location":"core-concepts/introduction-to-agents/#core-components-of-ai-agents","title":"Core Components of AI Agents","text":"<p>You can think of an AI agent as a guided LLM with instructions, tools, and contect. LLMs like Claude and Chat-GPT act in an input / output mode where each user input leads to an LLM output. Agents seem to perform the in the same way when looking at the surface: a user sends an input (prompt) and the agent produces an output. However, under the covers there is an agent loop that is happening.</p> <p></p> <p>The agent uses its instructions, tools, and context to decide when it has enough information to fulfill its prompt. It may make a tool call, analyze the result, and decide to make another tool call. This continues until the final goal is achieved.</p>"},{"location":"core-concepts/introduction-to-agents/#instructions","title":"Instructions","text":"<p>When creating an agent you supply it with instructions that outline its general purpose and goal. Instructions can be general, allowing the agent more agency (for lack of a better word). They can also be highly specific, guiding the agent in using its tools in a step by step process. Look at these examples from two of our example agents:</p>"},{"location":"core-concepts/introduction-to-agents/#basic-agent","title":"Basic Agent","text":"<pre><code>You are a helpful assistant that reports the weather.\n</code></pre>"},{"location":"core-concepts/introduction-to-agents/#ai-news-reporter","title":"AI News Reporter","text":"<pre><code>You are an experienced, hard-hitting news reporter. You are preparing a news report.\nFollow these steps precisely:\n    1. Search for headlines, using query_news, about \"AI and artificial intelligence\" but exclude \"motley fool\".\n    2. Download pages for the most interesting articles, max 10.\n    3. Now create a long, extensive \"morning news\" report in the style of NPR or CNN, but with a hard news edge, and reporting as \"Supercog News\", at least 10,000 characters. Do not print any paragraph headers.\n    4. Now convert the show into speech, choosing one of the available voices at random.\n</code></pre>"},{"location":"core-concepts/introduction-to-agents/#tools","title":"Tools","text":"<p>These are sets of functions that the agent may decide to use. For example, I could supply my agent with two tools: a weather tool and a news tool. When I ask the agent to \"Report the weather in New York City\" it knows to call the weather tool and not the news tool.</p>"},{"location":"core-concepts/introduction-to-agents/#context","title":"Context","text":"<p>A lot of the power of agents come from their context. They are able to leverage several types of context to look at the current computation holistically.</p> <ul> <li>Large Language Models (LLMs): LLMs have their own knowledge indexes that the agent can draw on.</li> <li>Short Term Memory: Short term memory is used to track things like previous prompts, tool results, error resolutions, etc.</li> <li>Long Term Memory: Long term memory can be added to the agent and persists across threads. Memories are set by the creator of the agent and can include things like remembering a certain piece of information, or how to correctly call a function.</li> <li>Reasoning: The agent takes all of these sources into account at each step, attempting to make the best decision to proceed toward its goal.</li> </ul>"},{"location":"core-concepts/introduction-to-agents/#agents-vs-llms","title":"Agents vs. LLMs","text":"<p>Large Language Models are typically a central component of modern AI agents, but the two are not synonymous:</p> <ul> <li>LLMs as Foundation: LLMs provide the language understanding, generation, and reasoning capabilities.</li> <li>Beyond LLMs: Agents extend LLMs with action capabilities, persistent memory, and goal-oriented behavior.</li> <li>Architectural Relationship: Generally, the LLM acts as the \"reasoning engine\" while agentic components handle tools, memory, and  execution.</li> </ul> <p>TLDR; Agents are built on top of LLMs.</p>"},{"location":"core-concepts/introduction-to-agents/#common-use-cases","title":"Common Use Cases","text":"Domain Use Cases Personal Assistants <ul><li>Meeting scheduling</li><li>Email management</li><li>Task automation</li> Customer Service <ul><li>Automated support agents</li><li>Issue troubleshooting</li><li>Complaint resolution</li> Research &amp; Analysis <ul><li>Data exploration</li><li>Literature review</li><li>Trend identification</li> Code &amp; Software Development <ul><li>Code generation and debugging</li><li>Testing automation</li><li>Documentation creation</li> Business Process Automation <ul><li>Document processing</li><li>Data entry and validation</li><li>Report generation</li>"},{"location":"core-concepts/introduction-to-agents/#key-challenges","title":"Key Challenges","text":"<ol> <li>Hallucination Management: Ensuring agents don't fabricate information or capabilities.</li> <li>Tool Integration: Creating reliable, secure interfaces between the agent and external systems.</li> <li>Goal Alignment: Making sure agent actions match user intentions and expectations.</li> <li>Context Limitations: Managing finite context windows and memory constraints.</li> </ol>"},{"location":"core-concepts/introduction-to-agents/#evaluation-metrics","title":"Evaluation Metrics","text":"<ul> <li>Task Completion Rate: Percentage of tasks successfully accomplished</li> <li>Efficiency: Steps or time required to complete tasks</li> <li>Autonomy: Level of human intervention required</li> <li>Adaptability: Performance across varied environments or tasks</li> </ul> <p>AI agents represent a significant evolution beyond traditional AI systems, combining the capabilities of foundation models with the ability to take actions, maintain memory, and pursue goals over extended interactions.</p>"},{"location":"core-concepts/models/","title":"Models","text":"<p>Agentic uses Litellm as the \"LLM router\" which allows us to support most popular LLMs via simple configuration.</p> <p>Models providers supported include:</p> <ul> <li>OpenAI</li> <li>Anthropic</li> <li>Google</li> <li>Llama3.x</li> <li>Deepseek</li> </ul> <p>and many more.</p> <p>When you specify the <code>model</code> parameter to your Agent, supply a qualified model name like:</p> <pre><code>openai/gpt-4o\n</code></pre> <p>or </p> <pre><code>anthropic/claude-3-5-sonnet-20240620\n</code></pre> <p>Try using <code>agentic models</code> at the command line to get a list of popular models.</p>"},{"location":"core-concepts/models/#ollama","title":"Ollama","text":"<p>Agentic has built-in support for using locally installed models via Ollama.</p> <p>To use, first install ollama. Then serve your model:</p> <pre><code>ollama run llama3.2:latest\n</code></pre> <p>And specify your agent's model:</p> <pre><code>model=ollama/llama3.2:latest\n</code></pre>"},{"location":"core-concepts/project-structure/","title":"Project Structure","text":"<p>An Agentic project has the following structure:</p> <pre><code>&lt;root&gt;/\n    pyproject.toml\n    agents/\n        agent1.py\n        agent1.prompts.yaml\n        agent2.py\n    tools/\n        weather_tool.py\n        news_tool.py\n        tests/\n            test_weather_tool.py\n            test_news_tool.py\n    indexes/\n        personal.rag.sqlite\n        dev.rag.sqlite\n    evals/\n        agent1.eval\n        agent2.eval\n    runtime/\n        agent_threads.db\n</code></pre>"},{"location":"deployment/","title":"Agentic AWS Deployment Guide","text":"<p>This guide provides step-by-step instructions for deploying your Agentic agents to AWS using Docker and Terraform. You can choose between deploying the API server or the dashboard interface.</p> <p>Note: If you have already completed the Getting Started guide, you can skip to Step 5.</p>"},{"location":"deployment/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have the following:</p> <ul> <li>Python 3.12</li> <li>Docker installed and running</li> <li>AWS CLI installed and configured</li> <li>Terraform installed (v1.0.0+)</li> <li>AWS Account with appropriate permissions</li> <li>API keys for your LLMs (OpenAI, Anthropic, etc.)</li> </ul>"},{"location":"deployment/#step-1-set-up-local-environment","title":"Step 1: Set Up Local Environment","text":"<p>Create a new directory for your project and navigate to it:</p> <pre><code>mkdir -p ~/agentic\ncd ~/agentic\nuv venv --python 3.12\nsource .venv/bin/activate\n</code></pre>"},{"location":"deployment/#step-2-install-agentic-framework","title":"Step 2: Install Agentic Framework","text":"<p>Next, install the Agentic framework with all optional dependencies:</p> <pre><code>pip install \"agentic-framework[all]\" --extra-index-url https://download.pytorch.org/whl/cpu\n</code></pre>"},{"location":"deployment/#step-3-initialize-your-project","title":"Step 3: Initialize Your Project","text":"<p>Initialize a new Agentic project:</p> <pre><code>agentic init\n</code></pre> <p>This will create the basic project structure with example agents and tools.</p>"},{"location":"deployment/#step-4-build-your-agent","title":"Step 4: Build Your Agent","text":"<p>Create or modify an agent in the <code>agents</code> directory. For example, <code>agents/basic_agent.py</code>:</p> <pre><code>from agentic.common import Agent, AgentRunner\nfrom agentic.tools import WeatherTool\n\nbasic_agent = Agent(\n    name=\"Weather Agent\",\n    welcome=\"I can give you weather reports! Just tell me which city.\",\n    instructions=\"You are a helpful assistant specializing in weather information.\",\n    tools=[WeatherTool()],\n    model=\"openai/gpt-4o-mini\"\n)\n\nif __name__ == \"__main__\":\n    AgentRunner(basic_agent).repl_loop()\n</code></pre> <p>Test your agent locally:</p> <pre><code>python agents/basic_agent.py\n</code></pre>"},{"location":"deployment/#step-5-configure-secrets","title":"Step 5: Configure Secrets","text":"<p>You have three options for configuring your secrets:</p>"},{"location":"deployment/#option-1-environment-file-env","title":"Option 1: Environment File (.env)","text":"<ol> <li>Copy the example environment file:</li> </ol> <pre><code>cp .env.example .env\n</code></pre> <ol> <li>Edit <code>.env</code> to add your API keys and other secrets:</li> </ol> <pre><code>OPENAI_API_KEY=sk-your-openai-key\nANTHROPIC_API_KEY=sk-ant-your-anthropic-key\n# Add other secrets as needed\n</code></pre> <p>When you build the docker image, the secrets will be automatically loaded into the container.</p>"},{"location":"deployment/#option-2-aws-secrets-manager-via-terraform","title":"Option 2: AWS Secrets Manager (via Terraform)","text":"<p>Secrets will be automatically configured in AWS Secrets Manager when you deploy using Terraform. You'll need to add your API keys to the <code>deployment/terraform/terraform.tfvars</code> file in step 6.</p> <p>This approach is recommended for production deployments as it provides better security and centralized management.</p>"},{"location":"deployment/#step-6-configure-terraform","title":"Step 6: Configure Terraform","text":"<ol> <li>Copy the example Terraform variables file:</li> </ol> <pre><code>cp deployment/terraform/example.terraform.tfvars deployment/terraform/terraform.tfvars\n</code></pre> <ol> <li>Edit <code>deployment/terraform/terraform.tfvars</code> to configure your deployment:</li> </ol> <pre><code># Project and Environment\nproject     = \"agentic\"\nenvironment = \"dev\"\n\n# AWS Region\naws_region = \"us-east-1\"\n\n# Network Settings\nvpc_cidr            = \"10.0.0.0/16\"\navailability_zones  = [\"us-east-1a\", \"us-east-1b\"]\nprivate_subnet_cidrs = [\"10.0.1.0/24\", \"10.0.2.0/24\"]\npublic_subnet_cidrs = [\"10.0.101.0/24\", \"10.0.102.0/24\"]\n\n# Deployment Mode - options: \"api\" or \"dashboard\"\ndeployment_mode = \"api\"\n\n# Port Settings\nagent_port     = 8086\ndashboard_port = 3000\n\n# ECS Settings\ntask_cpu              = \"1024\"  # 1 vCPU\ntask_memory           = \"2048\"  # 2 GB\nservice_desired_count = 1\n\n# Agent Settings\nagent_path  = \"agents/basic_agent.py\"  # Path to your agent file\nuser_agents = false  # Set to true if you want to enable user-specific agents\nuse_ray     = false  # Set to true if you want to use Ray for agent execution\n\n# Secrets Settings\nsecrets_values = {\n  OPENAI_API_KEY    = \"your-openai-api-key\"\n  ANTHROPIC_API_KEY = \"your-anthropic-api-key\"\n}\n\n# Secrets environment variables mapping\nsecrets_env_mapping = {\n  OPENAI_API_KEY    = \"OPENAI_API_KEY\"\n  ANTHROPIC_API_KEY = \"ANTHROPIC_API_KEY\"\n  # Add other secrets as needed\n}\n\n# Common tags for resources\ncommon_tags = {\n  Project     = \"agentic\"\n  Environment = \"dev\"\n  Terraform   = \"true\"\n}\n</code></pre> <p>The <code>deployment_mode</code> variable determines whether you deploy the API server or the dashboard interface.</p> <ol> <li>Update the <code>outputs.tf</code> file to include cluster and service information:</li> </ol> <pre><code># Outputs\noutput \"ecr_repository_url\" {\n  description = \"The ECR repository URL where you should push your Docker image\"\n  value       = aws_ecr_repository.app.repository_url\n}\n\noutput \"agent_endpoint\" {\n  description = \"The endpoint where the agent API or dashboard can be accessed\"\n  value       = aws_lb.app_alb.dns_name\n}\n\noutput \"ecs_cluster_name\" {\n  description = \"The name of the ECS cluster where the service is running\"\n  value       = aws_ecs_cluster.app_cluster.name\n}\n\noutput \"ecs_service_name\" {\n  description = \"The name of the ECS service\"\n  value       = aws_ecs_service.app.name\n}\n</code></pre>"},{"location":"deployment/#step-7-review-docker-configuration","title":"Step 7: Review Docker Configuration","text":"<p>Your deployment directory already contains the necessary Docker files:</p> <ol> <li>Dockerfile.api: For deploying the API server version of your agent</li> <li>Dockerfile.dashboard: For deploying the dashboard interface</li> <li>docker-entrypoint.sh: Script that handles environment variables and starts the appropriate service</li> </ol> <p>The <code>docker-entrypoint.sh</code> script manages:</p> <ul> <li>Loading environment variables from <code>.env</code> file</li> <li>Setting up the agent path</li> <li>Retrieving secrets from AWS Secrets Manager if configured</li> <li>Starting either the API server or dashboard based on the <code>DEPLOYMENT_MODE</code> environment variable</li> </ul> <p>Make sure the entrypoint script is executable:</p> <pre><code>chmod +x deployment/docker-entrypoint.sh\n</code></pre>"},{"location":"deployment/#step-8-build-the-terraform-configuration","title":"Step 8: Build the Terraform Configuration","text":"<p>Navigate to the terraform directory and initialize Terraform:</p> <pre><code>cd deployment/terraform\nterraform init\n</code></pre> <p>Review the infrastructure plan:</p> <pre><code>terraform plan\n</code></pre> <p>Apply the configuration to create the AWS resources:</p> <pre><code>terraform apply\n</code></pre> <p>You'll need to confirm the changes by typing <code>yes</code> when prompted.</p>"},{"location":"deployment/#step-9-build-and-deploy-the-docker-image","title":"Step 9: Build and Deploy the Docker Image","text":"<p>Return to the project root directory and log in to your ECR repository:</p> <pre><code>cd ../..  # Return to the project root from the terraform directory\nexport AWS_REGION=$(aws configure get region)\nexport ECR_REPO_URL=$(cd deployment/terraform &amp;&amp; terraform output -raw ecr_repository_url)\naws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REPO_URL}\n</code></pre> <p>Build and push the appropriate Docker image based on your deployment mode:</p> <pre><code># For API Server Deployment (if deployment_mode = \"api\" in terraform.tfvars)\ndocker build --platform linux/amd64 --tag ${ECR_REPO_URL}:latest --file deployment/Dockerfile.api .\ndocker push ${ECR_REPO_URL}:latest\n\n# OR\n\n# For Dashboard Deployment (if deployment_mode = \"dashboard\" in terraform.tfvars)\ndocker build --platform linux/amd64 --tag ${ECR_REPO_URL}:latest --file deployment/Dockerfile.dashboard .\ndocker push ${ECR_REPO_URL}:latest\n</code></pre> <p>Make sure the Docker image you build matches the <code>deployment_mode</code> you specified in your Terraform configuration.</p>"},{"location":"deployment/#step-10-force-a-new-ecs-deployment","title":"Step 10: Force a New ECS Deployment","text":"<p>After pushing your Docker image to ECR, you need to force a new deployment to the ECS service to ensure it uses the latest image. You can do this using either the AWS CLI or the AWS Console.</p>"},{"location":"deployment/#option-1-using-aws-cli-recommended","title":"Option 1: Using AWS CLI (Recommended)","text":"<p>You can force a new deployment using the AWS CLI with the following commands:</p> <pre><code># Get the ECS cluster and service names from Terraform output\nexport ECS_CLUSTER=$(cd deployment/terraform &amp;&amp; terraform output -raw ecs_cluster_name)\nexport ECS_SERVICE=$(cd deployment/terraform &amp;&amp; terraform output -raw ecs_service_name)\n\n# Force a new deployment\naws ecs update-service --cluster $ECS_CLUSTER --service $ECS_SERVICE --force-new-deployment\n\n# Monitor the deployment status\naws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --query \"services[0].deployments\"\n</code></pre> <p>This will trigger a new deployment of your service with the latest container image, without needing to make changes to your configuration.</p>"},{"location":"deployment/#option-2-using-aws-console","title":"Option 2: Using AWS Console","text":"<p>If you prefer using the AWS Console:</p> <ol> <li>Go to the AWS Console</li> <li>Navigate to ECS &gt; Clusters</li> <li>Select your cluster (typically named <code>agentic-{environment}-cluster</code>)</li> <li>Select the service for your agent</li> <li>Click on the \"Update service\" dropdown</li> <li>Click \"Force new deployment\"</li> <li>Click \"Confirm\" to apply the changes</li> </ol> <p>The force new deployment option will redeploy your containers with the latest image from ECR, even if the task definition hasn't changed.</p>"},{"location":"deployment/#step-11-test-your-deployment","title":"Step 11: Test Your Deployment","text":"<p>Get the endpoint URL from Terraform output:</p> <pre><code>export AGENT_ENDPOINT=$(cd deployment/terraform &amp;&amp; terraform output -raw agent_endpoint)\n</code></pre>"},{"location":"deployment/#testing-api-server-deployment","title":"Testing API Server Deployment","text":"<pre><code># Test the discovery endpoint\ncurl \"$AGENT_ENDPOINT/_discovery\"\n\n# Test your agent\ncurl -X POST \"$AGENT_ENDPOINT/basic-agent/process\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"prompt\": \"Hello, how can you help me?\"}'\n</code></pre>"},{"location":"deployment/#testing-dashboard-deployment","title":"Testing Dashboard Deployment","text":"<p>Open a web browser and navigate to the endpoint URL:</p> <pre><code>http://$AGENT_ENDPOINT\n</code></pre> <p>You should see the Agentic dashboard interface where you can interact with your agent.</p>"},{"location":"deployment/#step-12-monitor-your-deployment","title":"Step 12: Monitor Your Deployment","text":"<p>You can monitor your agent in the AWS Console:</p> <ol> <li>ECS: Check the status of your agent service</li> <li>CloudWatch: View logs from your agent</li> <li>ECR: Manage your Docker images</li> </ol>"},{"location":"deployment/#troubleshooting","title":"Troubleshooting","text":""},{"location":"deployment/#container-fails-to-start","title":"Container Fails to Start","text":"<p>Check CloudWatch Logs for detailed error messages:</p> <ol> <li>Go to the AWS Console</li> <li>Navigate to CloudWatch &gt; Log Groups</li> <li>Find the log group for your agent (usually <code>/ecs/agentic-{environment}</code>)</li> <li>Check the latest log stream for error messages</li> </ol>"},{"location":"deployment/#service-not-accessible","title":"Service Not Accessible","text":"<p>Verify the ALB health checks are passing:</p> <ol> <li>Go to the AWS Console</li> <li>Navigate to EC2 &gt; Load Balancers</li> <li>Select your load balancer and check the \"Target Groups\" tab</li> <li>Verify that targets are healthy</li> </ol> <p>If targets are unhealthy, check the following: - Security group rules allow traffic to the container port - Health check path is correctly configured for API (<code>/_discovery</code>) or Dashboard (<code>/api/_discovery</code>) - Agent is starting up correctly (check CloudWatch logs)</p>"},{"location":"deployment/#authentication-issues","title":"Authentication Issues","text":"<p>Ensure your API keys are correctly set up:</p> <p>For AWS Secrets Manager:</p> <ul> <li>Go to the AWS Console</li> <li>Navigate to Secrets Manager &gt; Secrets</li> <li>Check the value of your agent secrets</li> </ul> <p>For .env file:</p> <ul> <li>Verify the .env file has been correctly copied into the Docker image</li> <li>Check the container logs for any environment variable related errors</li> </ul>"},{"location":"deployment/#deployment-not-updating","title":"Deployment Not Updating","text":"<p>If you've pushed a new Docker image but the service isn't using it:</p> <ul> <li>Check that you pushed to the correct ECR repository</li> <li>Verify that the image tag is correct (usually <code>latest</code>)</li> <li>Make sure you forced a new deployment as described in Step 10</li> <li>Check the ECS deployments to see if there are any errors during the update</li> </ul>"},{"location":"deployment/#cleaning-up","title":"Cleaning Up","text":"<p>To destroy all AWS resources created by Terraform:</p> <pre><code>cd deployment/terraform\nterraform destroy\n</code></pre> <p>You'll need to confirm the deletion by typing <code>yes</code> when prompted.</p>"},{"location":"deployment/#customizing-your-deployment","title":"Customizing Your Deployment","text":""},{"location":"deployment/#scaling-your-agent","title":"Scaling Your Agent","text":"<p>To scale your agent deployment, adjust the following in <code>terraform.tfvars</code>:</p> <pre><code>service_desired_count = 2  # Number of instances to run\ntask_cpu = \"2048\"          # CPU units (1024 = 1 vCPU)\ntask_memory = \"4096\"       # Memory in MB\n</code></pre>"},{"location":"deployment/#using-a-custom-domain","title":"Using a Custom Domain","text":"<p>To use a custom domain with your agent:</p> <ol> <li>Create an HTTPS certificate in AWS Certificate Manager</li> <li>Add an HTTPS listener to the load balancer in your Terraform configuration</li> <li>Create a DNS record pointing to the load balancer</li> </ol>"},{"location":"deployment/#switching-between-api-and-dashboard","title":"Switching Between API and Dashboard","text":"<p>To switch between API server and dashboard deployments, update the <code>deployment_mode</code> variable in your <code>terraform.tfvars</code> file:</p> <pre><code># For API server\ndeployment_mode = \"api\"\n\n# For dashboard\ndeployment_mode = \"dashboard\"\n</code></pre> <p>Then run <code>terraform apply</code> to update your deployment, rebuild and push the appropriate Docker image, and force a new deployment as described in Step 10.</p>"},{"location":"deployment/updating-deployments/","title":"Updating Your Agentic Agent on AWS","text":"<p>This guide covers the process of updating your Agentic agent that has been deployed to AWS using the deployment process outlined in the Agentic AWS Deployment Guide.</p>"},{"location":"deployment/updating-deployments/#prerequisites","title":"Prerequisites","text":"<p>Before updating your agent, ensure you have:</p> <ul> <li>Access to your Agentic project codebase</li> <li>AWS CLI installed and configured</li> <li>Docker installed and running</li> <li>The necessary permissions to push to ECR and update ECS services</li> </ul>"},{"location":"deployment/updating-deployments/#step-1-update-your-agent-code","title":"Step 1: Update Your Agent Code","text":"<p>Modify your agent file in the <code>agents</code> directory with your desired changes:</p> <pre><code>from agentic.common import Agent, AgentRunner\nfrom agentic.tools import WeatherTool, GoogleNewsTool\n\n# Update model, tools, instructions, etc.\nupdated_agent = Agent(\n    name=\"Weather Agent 2.0\",\n    welcome=\"I can now give you detailed weather reports and the news!\",\n    instructions=\"You are a helpful assistant specializing in comprehensive weather information and current events.\",\n    tools=[WeatherTool(), GoogleNewsTool()],\n    model=\"openai/gpt-4o\"  # Upgraded model\n)\n\nif __name__ == \"__main__\":\n    AgentRunner(updated_agent).repl_loop()\n</code></pre> <p>Common updates include: - Adding new tools or capabilities - Upgrading the underlying model - Refining the agent's instructions or prompt engineering - Implementing additional business logic - Improving error handling</p>"},{"location":"deployment/updating-deployments/#step-2-test-your-changes-locally","title":"Step 2: Test Your Changes Locally","text":"<p>Before deploying to AWS, test your updates locally to ensure they work as expected:</p> <pre><code># Activate your virtual environment\ncd ~/agentic\nsource .venv/bin/activate\n\n# Run your updated agent\npython agents/your_updated_agent.py\n</code></pre> <p>Test all the new functionality and ensure there are no regressions in existing capabilities.</p>"},{"location":"deployment/updating-deployments/#step-3-update-configuration-if-needed","title":"Step 3: Update Configuration (If Needed)","text":"<p>If you've made changes that require configuration updates, modify your <code>terraform.tfvars</code> file:</p> <pre><code>cd deployment/terraform\n</code></pre> <p>Edit <code>terraform.tfvars</code> to update relevant settings:</p> <pre><code># Update agent path if you renamed or moved the agent file\nagent_path = \"agents/your_updated_agent.py\"\n\n# Update resource allocations if needed for larger models\ntask_cpu    = \"2048\"  # 2 vCPU\ntask_memory = \"4096\"  # 4 GB\n\n# Update any other relevant configuration variables\nuse_ray     = true    # Enable Ray for parallel processing if needed\n</code></pre> <p>If you've updated the configuration, apply the Terraform changes:</p> <pre><code>terraform plan    # Review the planned changes\nterraform apply   # Apply the changes\n</code></pre>"},{"location":"deployment/updating-deployments/#step-4-rebuild-and-push-the-docker-image","title":"Step 4: Rebuild and Push the Docker Image","text":"<p>Build a new Docker image with your updated code:</p> <pre><code># Navigate to the project root\ncd ~/agentic\n\n# Get your ECR repository URL\nexport AWS_REGION=$(aws configure get region)\nexport ECR_REPO_URL=$(cd deployment/terraform &amp;&amp; terraform output -raw ecr_repository_url)\n\n# Log in to ECR\naws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REPO_URL}\n</code></pre> <p>Build and push the appropriate Docker image based on your deployment mode:</p> <pre><code># For API Server Deployment\ndocker build --platform linux/amd64 --tag ${ECR_REPO_URL}:latest --file deployment/Dockerfile.api .\ndocker push ${ECR_REPO_URL}:latest\n\n# OR\n\n# For Dashboard Deployment\ndocker build --platform linux/amd64 --tag ${ECR_REPO_URL}:latest --file deployment/Dockerfile.dashboard .\ndocker push ${ECR_REPO_URL}:latest\n</code></pre>"},{"location":"deployment/updating-deployments/#step-5-force-a-new-deployment","title":"Step 5: Force a New Deployment","text":"<p>ECS doesn't automatically detect when you've pushed a new image with the same tag. You need to force a new deployment to apply your updates:</p> <pre><code># Get the ECS cluster and service names\nexport ECS_CLUSTER=$(cd deployment/terraform &amp;&amp; terraform output -raw ecs_cluster_name)\nexport ECS_SERVICE=$(cd deployment/terraform &amp;&amp; terraform output -raw ecs_service_name)\n\n# Force a new deployment\naws ecs update-service --cluster $ECS_CLUSTER --service $ECS_SERVICE --force-new-deployment\n</code></pre>"},{"location":"deployment/updating-deployments/#step-6-monitor-the-deployment","title":"Step 6: Monitor the Deployment","text":"<p>Monitor the deployment to ensure your updates are being applied successfully:</p> <pre><code># Check deployment status\naws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --query \"services[0].deployments\"\n</code></pre> <p>You should see a new deployment in progress with the status <code>PRIMARY</code> and the old deployment with the status <code>ACTIVE</code>. Once the new deployment is complete, the old deployment will be removed.</p> <p>Check the CloudWatch logs for any issues:</p> <pre><code># Get the name of the latest log stream\nLATEST_LOG_STREAM=$(aws logs describe-log-streams \\\n  --log-group-name \"/ecs/${ECS_CLUSTER}\" \\\n  --order-by LastEventTime \\\n  --descending \\\n  --limit 1 \\\n  --query \"logStreams[0].logStreamName\" \\\n  --output text)\n\n# View the logs\naws logs get-log-events \\\n  --log-group-name \"/ecs/${ECS_CLUSTER}\" \\\n  --log-stream-name \"$LATEST_LOG_STREAM\"\n</code></pre>"},{"location":"deployment/updating-deployments/#step-7-test-the-updated-deployment","title":"Step 7: Test the Updated Deployment","text":"<p>Test your updated agent to ensure everything is working as expected:</p> <pre><code># Get the endpoint URL\nexport AGENT_ENDPOINT=$(cd deployment/terraform &amp;&amp; terraform output -raw agent_endpoint)\n</code></pre>"},{"location":"deployment/updating-deployments/#for-api-server-deployments","title":"For API Server Deployments","text":"<pre><code># Test the discovery endpoint\ncurl \"$AGENT_ENDPOINT/_discovery\"\n\n# Test your agent\ncurl -X POST \"$AGENT_ENDPOINT/your-agent-name/process\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"prompt\": \"Test the new features\"}'\n</code></pre>"},{"location":"deployment/updating-deployments/#for-dashboard-deployments","title":"For Dashboard Deployments","text":"<p>Open a web browser and navigate to:</p> <pre><code>http://$AGENT_ENDPOINT\n</code></pre> <p>Interact with your agent through the dashboard interface to ensure it's working correctly.</p>"},{"location":"deployment/updating-deployments/#advanced-update-strategies","title":"Advanced Update Strategies","text":""},{"location":"deployment/updating-deployments/#using-image-versioning","title":"Using Image Versioning","text":"<p>Instead of always using the <code>latest</code> tag, consider implementing versioning for your Docker images:</p> <pre><code># Tag with version number\nexport VERSION=\"1.2.0\"\ndocker build --platform linux/amd64 --tag ${ECR_REPO_URL}:${VERSION} --file deployment/Dockerfile.api .\ndocker push ${ECR_REPO_URL}:${VERSION}\n\n# Also update latest for backward compatibility\ndocker tag ${ECR_REPO_URL}:${VERSION} ${ECR_REPO_URL}:latest\ndocker push ${ECR_REPO_URL}:latest\n</code></pre> <p>Update your task definition to use the specific version:</p> <pre><code>container_definitions = jsonencode([\n  {\n    name  = var.project\n    image = \"${aws_ecr_repository.app.repository_url}:1.2.0\"\n    # ...other config\n  }\n])\n</code></pre>"},{"location":"deployment/updating-deployments/#rolling-back-updates","title":"Rolling Back Updates","text":"<p>If you need to roll back to a previous version:</p> <ol> <li>Push the previous version image or use an existing tagged version</li> <li>Update the task definition to use the previous version</li> <li>Force a new deployment</li> </ol> <pre><code># Update task definition to use previous version\n# (Edit in Terraform or via AWS Console)\n\n# Force a new deployment\naws ecs update-service --cluster $ECS_CLUSTER --service $ECS_SERVICE --force-new-deployment\n</code></pre>"},{"location":"deployment/updating-deployments/#bluegreen-deployments","title":"Blue/Green Deployments","text":"<p>For zero-downtime updates, consider implementing blue/green deployments:</p> <ol> <li>Deploy the new version to a new ECS service</li> <li>Test the new deployment</li> <li>Switch the load balancer target group to the new service</li> <li>Terminate the old service once traffic is successfully routed</li> </ol> <p>This requires additional Terraform configuration but provides safer updates for production environments.</p>"},{"location":"deployment/updating-deployments/#maintaining-a-changelog","title":"Maintaining a Changelog","text":"<p>For better tracking of agent changes, maintain a changelog in your project:</p> <pre><code># Changelog\n\n## v1.2.0 (2025-05-15)\n- Added climate history tool\n- Upgraded to GPT-4o model\n- Improved error handling for API rate limits\n\n## v1.1.0 (2025-04-10)\n- Added forecast capability\n- Expanded location support\n- Fixed bug in temperature conversion\n\n## v1.0.0 (2025-03-01)\n- Initial release\n- Basic weather information support\n</code></pre>"},{"location":"deployment/updating-deployments/#automating-updates-with-cicd","title":"Automating Updates with CI/CD","text":"<p>Consider setting up a CI/CD pipeline (using GitHub Actions, GitLab CI, or AWS CodePipeline) to automate the update process:</p> <ol> <li>Push changes to your repository</li> <li>Automated tests run to validate the changes</li> <li>Docker image is built and pushed to ECR</li> <li>ECS service is updated with the new image</li> <li>Post-deployment tests verify the update</li> </ol> <p>This provides a more streamlined and reliable update process for production environments.</p>"},{"location":"deployment/updating-deployments/#troubleshooting-updates","title":"Troubleshooting Updates","text":""},{"location":"deployment/updating-deployments/#new-deployment-wont-start","title":"New Deployment Won't Start","text":"<p>If the new task won't start:</p> <ol> <li>Check the task definition for any issues</li> <li>Verify resource constraints (CPU/memory)</li> <li>Check the Docker image exists in ECR</li> <li>Look for errors in the CloudWatch logs</li> </ol>"},{"location":"deployment/updating-deployments/#service-unhealthy-after-update","title":"Service Unhealthy After Update","text":"<p>If the service is unhealthy after the update:</p> <ol> <li>Check that health check endpoints are working</li> <li>Verify the agent is starting up correctly</li> <li>Check for any runtime errors in the logs</li> <li>Ensure the correct ports are exposed</li> </ol>"},{"location":"deployment/updating-deployments/#agent-not-behaving-as-expected","title":"Agent Not Behaving as Expected","text":"<p>If the agent isn't working as expected after the update:</p> <ol> <li>Verify the correct agent file is being used</li> <li>Check environment variables and secrets are properly set</li> <li>Verify API keys are valid and have sufficient quota</li> <li>Test the specific functionality that's not working correctly</li> </ol>"},{"location":"interacting-with-agents/","title":"Interacting with Agents","text":"<p>Agentic provides several ways to interact with your agents, ranging from simple CLI interfaces to full-featured web applications. This section covers the different methods available.</p>"},{"location":"interacting-with-agents/#available-interfaces","title":"Available Interfaces","text":"Interface Use Case Features Command Line (CLI) Quick testing, scripting Simple text I/O, dot commands REST API Integration with other applications HTTP endpoints, event streaming Next.js Dashboard Professional web UI Real-time updates, run history, background tasks Streamlit Dashboard Quick prototyping Simple web UI with minimal setup"},{"location":"interacting-with-agents/#command-line-interface","title":"Command Line Interface","text":"<p>The CLI is the simplest way to interact with your agents. It provides a REPL (Read-Eval-Print Loop) interface for direct conversations.</p> <pre><code>agentic thread examples/basic_agent.py\n</code></pre> <p>Special \"dot commands\" give you access to debugging features and agent controls:</p> <pre><code>.debug tools      # Show tool calls\n.model claude-3   # Switch models\n.history          # Show conversation history\n.help             # See all available commands\n</code></pre> <p>Learn more about the CLI \u2192</p>"},{"location":"interacting-with-agents/#rest-api","title":"REST API","text":"<p>The REST API allows you to integrate agents with web applications, automation systems, or other services. It exposes endpoints for starting conversations, getting events, managing runs, and more.</p> <pre><code>agentic serve examples/basic_agent.py\n</code></pre> <p>This starts a FastAPI server that provides: - Agent discovery - Process requests - Event streaming - Run history and logs</p> <p>Learn more about the REST API \u2192</p>"},{"location":"interacting-with-agents/#nextjs-dashboard","title":"Next.js Dashboard","text":"<p>The Next.js Dashboard provides a full-featured web interface for interacting with your agents, with support for:</p> <ul> <li>Multiple agent management</li> <li>Real-time event streaming</li> <li>Background task management</li> <li>Run history and logs</li> <li>Markdown rendering</li> </ul> <pre><code>agentic dashboard start --agent-path examples/basic_agent.py\n</code></pre> <p>Learn more about the Next.js Dashboard \u2192</p>"},{"location":"interacting-with-agents/#streamlit-dashboard","title":"Streamlit Dashboard","text":"<p>The Streamlit Dashboard offers a lightweight web interface for quick prototyping and visualization.</p> <pre><code>agentic streamlit\n</code></pre> <p>Learn more about the Streamlit Dashboard \u2192</p>"},{"location":"interacting-with-agents/#programmatic-access","title":"Programmatic Access","text":"<p>In addition to these interfaces, you can always interact with agents programmatically in your Python code:</p> <pre><code>from agentic.common import Agent\n\n# Create an agent\nagent = Agent(\n    name=\"My Agent\",\n    instructions=\"You are a helpful assistant.\",\n    model=\"openai/gpt-4o-mini\"\n)\n\n# Use the &lt;&lt; operator for a quick response\nresponse = agent &lt;&lt; \"Hello, how are you?\"\nprint(response)\n\n# For more control over the conversation\nrequest_id = agent.start_request(\"Tell me a joke\").request_id\nfor event in agent.get_events(request_id):\n    print(event)\n</code></pre>"},{"location":"interacting-with-agents/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about the CLI options and features</li> <li>Set up the REST API for integration with other applications</li> <li>Explore the Next.js Dashboard for a full-featured web interface</li> <li>Try the Streamlit Dashboard for quick prototyping</li> </ul>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/","title":"REST API","text":"<p>Agentic includes built-in support for exposing your agent via a REST API using FastAPI. This API makes it easy to integrate your agents with web applications, automation tools, or other services.</p>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#starting-the-api-server","title":"Starting the API Server","text":"<p>You can start the API server in three ways:</p>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#1-using-agentrunner-in-code","title":"1. Using AgentRunner in code","text":"<pre><code>from agentic.common import Agent, AgentRunner\n\nagent = Agent(name=\"MyAgent\", instructions=\"You are a helpful assistant.\")\nAgentRunner(agent).serve()\n</code></pre>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#2-using-the-cli","title":"2. Using the CLI","text":"<p>The more common approach is to use the command-line interface:</p> <pre><code>agentic serve examples/basic_agent.py\n</code></pre> <p>To enable detailed logging:</p> <pre><code>AGENTIC_DEBUG=all agentic serve examples/basic_agent.py\n</code></pre>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#3-starting-with-a-custom-port","title":"3. Starting with a custom port","text":"<p>By default, the server runs on port 8086. You can specify a different port:</p> <pre><code>agentic serve examples/basic_agent.py --port 9000\n</code></pre>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#api-endpoints","title":"API Endpoints","text":"<p>The API server exposes several endpoints for each registered agent. </p>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#discovery-endpoint","title":"Discovery Endpoint","text":"<pre><code>GET /_discovery\n</code></pre> <p>Returns a list of all available agent paths.</p> <p>Example Response:</p> <pre><code>[\"/basic_agent\", \"/weather_agent\"]\n</code></pre>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#agent-endpoints","title":"Agent Endpoints","text":"<p>Each agent is accessible at its own path, determined by the agent's <code>safe_name</code> (lowercased name with special characters replaced by underscores):</p> <pre><code>http://0.0.0.0:8086/&lt;agent_name&gt;\n</code></pre>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#describe-agent","title":"Describe Agent","text":"<pre><code>GET /&lt;agent_name&gt;/describe\n</code></pre> <p>Returns metadata about the agent, including its name, purpose, tools, and available operations.</p> <p>Example Response:</p> <pre><code>{\n  \"name\": \"Weather Agent\",\n  \"purpose\": \"I can provide weather information for any location.\",\n  \"tools\": [\"get_current_weather\", \"get_forecast\"],\n  \"endpoints\": [\"/process\", \"/getevents\", \"/describe\"],\n  \"operations\": [\"chat\"],\n  \"prompts\": {\n    \"help\": \"Here's how to use the Weather Agent...\"\n  }\n}\n</code></pre>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#process-request","title":"Process Request","text":"<pre><code>POST /&lt;agent_name&gt;/process\n</code></pre> <p>Starts a new agent request/conversation turn.</p> <p>Request Body:</p> <pre><code>{\n  \"prompt\": \"What's the weather in New York?\",\n  \"debug\": \"tools\",  // Optional: Enable debug logging\n  \"thread_id\": \"abc123\" // Optional: Specify run ID for tracking\n}\n</code></pre> <p>Example Response:</p> <pre><code>{\n  \"request_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"thread_id\": \"abc123\"\n}\n</code></pre>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#get-events","title":"Get Events","text":"<pre><code>GET /&lt;agent_name&gt;/getevents?request_id=550e8400-e29b-41d4-a716-446655440000&amp;stream=true\n</code></pre> <p>Retrieves events from a running agent request. Can be used in two modes:</p> <ul> <li>Non-streaming (<code>stream=false</code>): Returns all completed events</li> <li>Streaming (<code>stream=true</code>): Returns a Server-Sent Events (SSE) stream</li> </ul> <p>Parameters:</p> <ul> <li><code>request_id</code>: (Required) The ID returned from the <code>/process</code> endpoint</li> <li><code>stream</code>: (Optional) Whether to use streaming mode (default: false)</li> </ul> <p>Example Non-Streaming Response:</p> <pre><code>[\n  {\n    \"type\": \"prompt_started\",\n    \"agent\": \"Weather Agent\",\n    \"depth\": 0,\n    \"payload\": \"What's the weather in New York?\"\n  },\n  {\n    \"type\": \"chat_output\",\n    \"agent\": \"Weather Agent\",\n    \"depth\": 0,\n    \"payload\": \"I'll check the weather for New York.\"\n  },\n  {\n    \"type\": \"tool_call\",\n    \"agent\": \"Weather Agent\",\n    \"depth\": 0,\n    \"payload\": {\n      \"name\": \"get_current_weather\",\n      \"arguments\": {\n        \"location\": \"New York\"\n      }\n    }\n  },\n  {\n    \"type\": \"tool_result\",\n    \"agent\": \"Weather Agent\",\n    \"depth\": 0,\n    \"payload\": \"Temperature: 72\u00b0F, Condition: Partly Cloudy\"\n  },\n  {\n    \"type\": \"chat_output\",\n    \"agent\": \"Weather Agent\",\n    \"depth\": 0,\n    \"payload\": \"The current weather in New York is 72\u00b0F and partly cloudy.\"\n  },\n  {\n    \"type\": \"turn_end\",\n    \"agent\": \"Weather Agent\",\n    \"depth\": 0,\n    \"payload\": \"The current weather in New York is 72\u00b0F and partly cloudy.\"\n  }\n]\n</code></pre>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#stream-request","title":"Stream Request","text":"<pre><code>POST /&lt;agent_name&gt;/stream_request\n</code></pre> <p>Combines the process and getevents steps into a single endpoint that returns an SSE stream.</p> <p>Request Body:</p> <pre><code>{\n  \"prompt\": \"What's the weather in New York?\",\n  \"debug\": \"tools\",\n  \"thread_id\": \"abc123\"\n}\n</code></pre> <p>Example Stream Response: A series of SSE events, each containing a serialized Event object.</p>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#resume-request","title":"Resume Request","text":"<pre><code>POST /&lt;agent_name&gt;/resume\n</code></pre> <p>Resumes an existing request that was paused waiting for user input.</p> <p>Request Body:</p> <pre><code>{\n  \"continue_result\": {\n    \"location\": \"New York\",\n    \"request_id\": \"550e8400-e29b-41d4-a716-446655440000\"\n  },\n  \"debug\": \"tools\",\n  \"thread_id\": \"abc123\"\n}\n</code></pre> <p>Example Response:</p> <pre><code>{\n  \"request_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"thread_id\": \"abc123\"\n}\n</code></pre>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#get-runs","title":"Get Runs","text":"<pre><code>GET /&lt;agent_name&gt;/runs\n</code></pre> <p>Returns a list of all historical runs for this agent.</p> <p>Example Response:</p> <pre><code>[\n  {\n    \"id\": \"abc123\",\n    \"agent_name\": \"Weather Agent\",\n    \"status\": \"completed\",\n    \"start_time\": \"2025-03-25T14:30:22.123456\",\n    \"end_time\": \"2025-03-25T14:30:25.789012\",\n    \"request\": \"What's the weather in New York?\",\n    \"response\": \"The current weather in New York is 72\u00b0F and partly cloudy.\"\n  }\n]\n</code></pre>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#get-run-logs","title":"Get Run Logs","text":"<pre><code>GET /&lt;agent_name&gt;/runs/{thread_id}/logs\n</code></pre> <p>Returns detailed logs for a specific run.</p> <p>Example Response:</p> <pre><code>[\n  {\n    \"id\": \"log1\",\n    \"thread_id\": \"abc123\",\n    \"timestamp\": \"2025-03-25T14:30:22.123456\",\n    \"event_type\": \"prompt_started\",\n    \"content\": \"What's the weather in New York?\"\n  },\n  {\n    \"id\": \"log2\",\n    \"thread_id\": \"abc123\",\n    \"timestamp\": \"2025-03-25T14:30:23.456789\",\n    \"event_type\": \"tool_call\",\n    \"content\": \"{\\\"name\\\": \\\"get_current_weather\\\", \\\"arguments\\\": {\\\"location\\\": \\\"New York\\\"}}\"\n  }\n]\n</code></pre>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#webhook","title":"Webhook","text":"<pre><code>POST /&lt;agent_name&gt;/webhook/{thread_id}/{callback_name}\n</code></pre> <p>Handles webhook callbacks for asynchronous tool operations.</p> <p>Path Parameters:</p> <ul> <li><code>thread_id</code>: The ID of the agent run</li> <li><code>callback_name</code>: Name of the tool function to call</li> </ul> <p>Request Body: The request body can include any parameters needed by the callback function. These are passed to the tool as arguments.</p> <p>Example Response:</p> <pre><code>{\n  \"status\": \"success\",\n  \"result\": \"Webhook processed successfully\"\n}\n</code></pre>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#working-with-events","title":"Working with Events","text":"<p>When building a client for the Agentic API, you'll need to process various events returned by the agent. Here are the key event types:</p> <ul> <li><code>prompt_started</code>: Indicates the agent has started processing a prompt</li> <li><code>chat_output</code>: Text generated by the agent's LLM</li> <li><code>tool_call</code>: Agent is calling a tool with specific arguments</li> <li><code>tool_result</code>: Result returned from a tool call</li> <li><code>tool_error</code>: Error that occurred during a tool call</li> <li><code>turn_end</code>: Final result of the request</li> <li><code>wait_for_input</code>: Agent is waiting for user input to continue</li> </ul> <p>Each event includes:</p> <ul> <li><code>type</code>: The event type</li> <li><code>agent</code>: Name of the agent that generated the event</li> <li><code>depth</code>: Nesting level (0 for top-level agent, 1+ for sub-agents)</li> <li><code>payload</code>: Event-specific data</li> </ul>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#client-implementation-example","title":"Client Implementation Example","text":"<p>Below is a simple JavaScript client example that processes a request and handles the event stream. See the Next.js Dashboard Docs and Implementation for a more complete implementation example.</p> <pre><code>async function chatWithAgent(agentName, message) {\n  // Start a request\n  const response = await fetch(`http://localhost:8086/${agentName}/process`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ prompt: message })\n  });\n\n  const { request_id } = await response.json();\n\n  // Create event source to receive events\n  const eventSource = new EventSource(`http://localhost:8086/${agentName}/getevents?request_id=${request_id}&amp;stream=true`);\n\n  eventSource.onmessage = (event) =&gt; {\n    const agentEvent = JSON.parse(event.data);\n\n    switch(agentEvent.type) {\n      case 'chat_output':\n        console.log(`Agent: ${agentEvent.payload}`);\n        break;\n      case 'tool_call':\n        console.log(`Using tool: ${agentEvent.payload.name}`);\n        break;\n      case 'wait_for_input':\n        // Handle user input required\n        eventSource.close();\n        const userInput = prompt(agentEvent.payload.message);\n        resumeConversation(agentName, request_id, agentEvent.payload.key, userInput);\n        break;\n      case 'turn_end':\n        console.log('Conversation turn complete');\n        eventSource.close();\n        break;\n    }\n  };\n}\n\nasync function resumeConversation(agentName, requestId, key, value) {\n  const response = await fetch(`http://localhost:8086/${agentName}/resume`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      continue_result: {\n        [key]: value,\n        request_id: requestId\n      }\n    })\n  });\n\n  // Continue handling events...\n}\n</code></pre>"},{"location":"interacting-with-agents/%5BDEPRECIATED%5D-rest-api-no-swagger/#api-documentation","title":"API Documentation","text":"<p>You can access the FastAPI-generated OpenAPI documentation at:</p> <pre><code>http://0.0.0.0:8086/&lt;agent_name&gt;/docs\n</code></pre> <p>This interactive documentation allows you to test endpoints directly in your browser.</p>"},{"location":"interacting-with-agents/cli/","title":"CLI","text":""},{"location":"interacting-with-agents/cli/#global-commands","title":"Global Commands","text":"<pre><code>init            - Initialize a new project by copying example files from the package\nthread          - Start interactive CLI session with an agent\nserve           - Runs the FastAPI server for an agent\nshell           - Copies secrets into the Environment and Runs a shell command\nstreamlit       - Run the Streamlit UI\n</code></pre>"},{"location":"interacting-with-agents/cli/#secrets-management","title":"Secrets Management","text":"<pre><code>secrets set     - Set a secret value\nsecrets list    - List all secrets (use --values to show values)\nsecrets get     - Get a secret value\nsecrets delete  - Delete a secret\n</code></pre>"},{"location":"interacting-with-agents/cli/#dashboard-commands","title":"Dashboard Commands","text":"<pre><code>dashboard start - Start the dashboard server\ndashboard build - Build the dashboard for production\n</code></pre>"},{"location":"interacting-with-agents/cli/#index-management","title":"Index Management","text":"<pre><code>index add             - Create a new index\nindex list            - List all available indexes\nindex rename          - Rename an index\nindex delete          - Delete an index\nindex search          - Search in an index\n\nindex document add    - Add a document to an index\nindex document list   - List documents in an index\nindex document show   - Show document details\nindex document delete - Delete a document from an index\n</code></pre>"},{"location":"interacting-with-agents/cli/#model-operations","title":"Model Operations","text":"<pre><code>models list     - List available LLM models\nmodels ollama   - List popular Ollama models\nmodels claude   - Run completion with Claude\nmodels gpt      - Run completion with GPT (use --model to override)\n</code></pre>"},{"location":"interacting-with-agents/nextjs-dashboard/","title":"Next.js Dashboard","text":"<p>The Agentic Dashboard is a web-based interface for interacting with your agents, monitoring their activities, and reviewing their run history. Built with Next.js, it provides a modern, responsive UI that connects to your agents through the Agentic framework's REST API.</p> <p></p>"},{"location":"interacting-with-agents/nextjs-dashboard/#overview","title":"Overview","text":"<p>The dashboard offers the following features:</p> <ul> <li>Chat with any registered agent</li> <li>View real-time agent event logs</li> <li>Run agents in the background while continuing to use the interface</li> <li>Browse thread history to review past agent executions</li> <li>Monitor agent performance metrics</li> </ul>"},{"location":"interacting-with-agents/nextjs-dashboard/#setup-and-installation","title":"Setup and Installation","text":""},{"location":"interacting-with-agents/nextjs-dashboard/#prerequisites","title":"Prerequisites","text":"<p>The dashboard requires:</p> <ul> <li>Node.js (v18+) </li> <li>npm (v8+)</li> <li>The Agentic framework with the dashboard extras</li> </ul> <p>To install with dashboard support:</p> <pre><code>pip install agentic-framework\n</code></pre>"},{"location":"interacting-with-agents/nextjs-dashboard/#building-the-dashboard","title":"Building the Dashboard","text":"<p>While not usually necessary, you can pre-build the dashboard for production:</p> <pre><code>agentic dashboard build\n</code></pre> <p>This compiles the Next.js application with optimizations for production use.</p>"},{"location":"interacting-with-agents/nextjs-dashboard/#running-the-dashboard","title":"Running the Dashboard","text":"<p>There are two ways to run the dashboard:</p>"},{"location":"interacting-with-agents/nextjs-dashboard/#using-the-cli","title":"Using the CLI","text":"<p>The simplest way to launch the dashboard is through the CLI:</p> <pre><code># Start in production mode\nagentic dashboard start\n\n# Start in development mode with live reloading\nagentic dashboard start --dev\n\n# Specify a custom port\nagentic dashboard start --port 8000\n\n# Start an agent server alongside the dashboard\nagentic dashboard start --agent-path examples/basic_agent.py\n</code></pre>"},{"location":"interacting-with-agents/nextjs-dashboard/#programmatically","title":"Programmatically","text":"<p>You can also start the dashboard from Python code:</p> <pre><code>from agentic.dashboard import setup\n\n# Start the dashboard\nprocess = setup.start_dashboard(port=3000, dev_mode=False)\n\n# To stop the dashboard:\n# process.terminate()\n</code></pre>"},{"location":"interacting-with-agents/nextjs-dashboard/#architecture","title":"Architecture","text":"<p>The dashboard uses a client-server architecture:</p> <ol> <li>The Backend Server is your Agentic API server (started with <code>agentic serve</code> or <code>agentic dashboard start --agent-path &lt;path&gt;</code>)</li> <li>The Frontend Dashboard is the Next.js application that communicates with the backend</li> </ol>"},{"location":"interacting-with-agents/nextjs-dashboard/#backend-integration","title":"Backend Integration","text":"<p>The dashboard integrates with the Agentic framework's REST API endpoints:</p> <ul> <li><code>/_discovery</code> - Lists all available agents</li> <li><code>/&lt;agent_path&gt;/describe</code> - Gets agent information</li> <li><code>/&lt;agent_path&gt;/process</code> - Sends prompts to an agent</li> <li><code>/&lt;agent_path&gt;/getevents</code> - Streams events from an agent</li> <li><code>/&lt;agent_path&gt;/threads</code> - Gets thread history</li> <li><code>/&lt;agent_path&gt;/threads/{id}/logs</code> - Gets logs for a specific thread</li> </ul> <p>The API integration is implemented in <code>src/app/lib/api.ts</code>, which provides a client-side wrapper around these endpoints.</p>"},{"location":"interacting-with-agents/nextjs-dashboard/#component-structure","title":"Component Structure","text":"<p>The dashboard is built with modular React components:</p> <ul> <li><code>AgentChat</code> - The main chat interface for interacting with agents</li> <li><code>AgentSidebar</code> - Navigation sidebar for agent selection and thead history</li> <li><code>EventLogs</code> - Real-time event log viewer</li> <li><code>BackgroundTasks</code> - Background task manager</li> <li><code>ThreadsTable</code> - Table of historical agent threads</li> <li><code>MarkdownRenderer</code> - Renderer for agent markdown responses</li> </ul>"},{"location":"interacting-with-agents/nextjs-dashboard/#data-flow","title":"Data Flow","text":"<p>Data flows through the application using the following pattern:</p> <ol> <li>The <code>useAgentData</code> hook fetches available agents and their information</li> <li>The <code>useChat</code> hook manages chat interactions and event streaming</li> <li>Components render the UI based on this data</li> <li>User actions trigger API calls which update the data</li> </ol>"},{"location":"interacting-with-agents/nextjs-dashboard/#event-streaming","title":"Event Streaming","text":"<p>A key feature of the dashboard is real-time event streaming from agents. This works through Server-Sent Events (SSE):</p> <ol> <li>When a user sends a prompt, the dashboard calls the <code>/process</code> endpoint</li> <li>It then connects to the <code>/getevents</code> endpoint with the request ID</li> <li>The server streams events as they occur (chat output, tool calls, etc.)</li> <li>The client processes these events and updates the UI accordingly</li> </ol> <p>The <code>useChat</code> hook encapsulates this logic, providing components with a clean interface for chat functionality.</p>"},{"location":"interacting-with-agents/nextjs-dashboard/#background-tasks","title":"Background Tasks","text":"<p>Agents can be run in the background while you continue using the interface:</p> <ol> <li>Enter a prompt and click the background task button</li> <li>The task runs independently of the main chat thread</li> <li>You can monitor its progress in the background tasks panel</li> <li>Results are stored and can be reviewed later</li> </ol> <p>This feature is particularly useful for long-running tasks.</p>"},{"location":"interacting-with-agents/nextjs-dashboard/#development-mode","title":"Development Mode","text":"<p>For dashboard development, use the <code>--dev</code> flag:</p> <pre><code>agentic dashboard start --dev\n</code></pre> <p>This launches Next.js in development mode with: - Hot module reloading - Detailed error messages - Source maps for debugging</p>"},{"location":"interacting-with-agents/nextjs-dashboard/#customization","title":"Customization","text":"<p>The dashboard uses Tailwind CSS for styling and can be customized by modifying:</p> <ul> <li><code>tailwind.config.ts</code> for theme settings</li> <li><code>globals.css</code> for global styles</li> <li>Component-level styles within each React component</li> </ul>"},{"location":"interacting-with-agents/nextjs-dashboard/#troubleshooting","title":"Troubleshooting","text":"<p>Common issues and solutions:</p> <ul> <li>Dashboard fails to start: Ensure Node.js and npm are installed and up to date</li> <li>Cannot connect to agents: Make sure the Agentic server is running (<code>agentic serve</code> or <code>agentic dashboard start --agent-path &lt;path&gt;</code>)</li> <li>UI not updating after changes: Make sure you started the dashboard in development mode (<code>--dev</code>)</li> </ul>"},{"location":"interacting-with-agents/rest-api/","title":"REST API","text":"<p>Agentic includes built-in support for exposing your agent via a REST API using FastAPI. This API makes it easy to integrate your agents with web applications, automation tools, or other services.</p>"},{"location":"interacting-with-agents/rest-api/#starting-the-api-server","title":"Starting the API Server","text":"<p>You can start the API server in three ways:</p>"},{"location":"interacting-with-agents/rest-api/#1-using-agentrunner-in-code","title":"1. Using AgentRunner in code","text":"<pre><code>from agentic.common import Agent, AgentRunner\n\nagent = Agent(name=\"MyAgent\", instructions=\"You are a helpful assistant.\")\nAgentRunner(agent).serve()\n</code></pre>"},{"location":"interacting-with-agents/rest-api/#2-using-the-cli","title":"2. Using the CLI","text":"<p>The more common approach is to use the command-line interface:</p> <pre><code>agentic serve examples/basic_agent.py\n</code></pre> <p>To enable detailed logging:</p> <pre><code>AGENTIC_DEBUG=all agentic serve examples/basic_agent.py\n</code></pre>"},{"location":"interacting-with-agents/rest-api/#3-starting-with-a-custom-port","title":"3. Starting with a custom port","text":"<p>By default, the server runs on port 8086. You can specify a different port:</p> <pre><code>agentic serve examples/basic_agent.py --port 9000\n</code></pre>"},{"location":"interacting-with-agents/rest-api/#api-swagger","title":"API Swagger","text":""},{"location":"interacting-with-agents/rest-api/#working-with-events","title":"Working with Events","text":"<p>When building a client for the Agentic API, you'll need to process various events returned by the agent. Here are the key event types:</p> <ul> <li><code>prompt_started</code>: Indicates the agent has started processing a prompt</li> <li><code>chat_output</code>: Text generated by the agent's LLM</li> <li><code>tool_call</code>: Agent is calling a tool with specific arguments</li> <li><code>tool_result</code>: Result returned from a tool call</li> <li><code>tool_error</code>: Error that occurred during a tool call</li> <li><code>turn_end</code>: Final result of the request</li> <li><code>wait_for_input</code>: Agent is waiting for user input to continue</li> </ul> <p>Each event includes:</p> <ul> <li><code>type</code>: The event type</li> <li><code>agent</code>: Name of the agent that generated the event</li> <li><code>depth</code>: Nesting level (0 for top-level agent, 1+ for sub-agents)</li> <li><code>payload</code>: Event-specific data</li> </ul>"},{"location":"interacting-with-agents/rest-api/#client-implementation-example","title":"Client Implementation Example","text":"<p>Below is a simple JavaScript client example that processes a request and handles the event stream. See the Next.js Dashboard Docs and Implementation for a more complete implementation example.</p> <pre><code>async function chatWithAgent(agentName, message) {\n  // Start a request\n  const response = await fetch(`http://localhost:8086/${agentName}/process`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ prompt: message })\n  });\n\n  const { request_id } = await response.json();\n\n  // Create event source to receive events\n  const eventSource = new EventSource(`http://localhost:8086/${agentName}/getevents?request_id=${request_id}&amp;stream=true`);\n\n  eventSource.onmessage = (event) =&gt; {\n    const agentEvent = JSON.parse(event.data);\n\n    switch(agentEvent.type) {\n      case 'chat_output':\n        console.log(`Agent: ${agentEvent.payload}`);\n        break;\n      case 'tool_call':\n        console.log(`Using tool: ${agentEvent.payload.name}`);\n        break;\n      case 'wait_for_input':\n        // Handle user input required\n        eventSource.close();\n        const userInput = prompt(agentEvent.payload.message);\n        resumeConversation(agentName, request_id, agentEvent.payload.key, userInput);\n        break;\n      case 'turn_end':\n        console.log('Conversation turn complete');\n        eventSource.close();\n        break;\n    }\n  };\n}\n\nasync function resumeConversation(agentName, requestId, key, value) {\n  const response = await fetch(`http://localhost:8086/${agentName}/resume`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      continue_result: {\n        [key]: value,\n        request_id: requestId\n      }\n    })\n  });\n\n  // Continue handling events...\n}\n</code></pre>"},{"location":"interacting-with-agents/rest-api/#api-documentation","title":"API Documentation","text":"<p>You can access the FastAPI-generated OpenAPI documentation at:</p> <pre><code>http://0.0.0.0:8086/&lt;agent_name&gt;/docs\n</code></pre> <p>This interactive documentation allows you to test endpoints directly in your browser.</p>"},{"location":"interacting-with-agents/rest-api/#supporting-multiple-users","title":"Supporting multiple users","text":"<p>By default <code>agentic serve</code> will use the single Agent instance that you create in your code to handle all requests. This works well for simple cases.</p> <p>In a real production application however you may want to support multiple users. In this case each user gets a separate instance of the agent to handle their requests.</p> <p>Follow these steps to support multiple users:</p> <ol> <li>Instead of using <code>agentic serve</code>, construct the API server and run it manually:</li> </ol> <pre><code>from agentic.api import AgentAPIServer\nserver = AgentAPIServer(agent_instances=agent_instances, port=port, lookup_user=get_current_user_from_token)\nuvicorn.run(server.app, host=\"0.0.0.0\", port=port)\n</code></pre> <p>you should pass a callback into the <code>lookup_user</code> parameter. This function takes an auth token and returns the user object based on that token.</p> <ol> <li>Your client should pass the <code>Authorization</code> header and include a JWT or other token to authenticate the user, like:</li> </ol> <p><code>Authorization: Bearer &lt;token&gt;</code></p> <ol> <li>In your callback you should lookup the user by the token. For a JWT you might do this:</li> </ol> <pre><code>async def get_current_user_from_token(session_token: str) -&gt; Optional[User]:\n    payload = jwt.decode(session_token, SECRET_KEY)\n    user = User(\n        id=payload.get(\"sub\"),\n        email=payload.get(\"email\"),\n        name=payload.get(\"name\"),\n    )\n    return user\n</code></pre> <ol> <li>The object you return as the \"user\" is opaque. But the framework will call <code>hash</code> on it and construct and re-use a dedicated instance of your Agent class mapped to that id.</li> </ol>"},{"location":"interacting-with-agents/streamlit-dashboard/","title":"Streamlit Dashboard","text":"<p>The Agentic Streamlit Dashboard provides a user-friendly web interface for interacting with your agents. Built with Streamlit, it provides a modern, simple UI for chatting with your agents.</p> <p></p>"},{"location":"interacting-with-agents/streamlit-dashboard/#features","title":"Features","text":"<p>The dashboard offers the following capabilities:</p> <ul> <li>Agent Chat Interface: Chat with any registered agent</li> <li>Real-time Event Logging: View agent events as they happen</li> <li>Tool Usage Visualization: See which tools your agents are using</li> <li>Token Usage Metrics: Monitor model token consumption</li> <li>Agent Discovery: Automatically displays all available agents</li> </ul>"},{"location":"interacting-with-agents/streamlit-dashboard/#setup-and-installation","title":"Setup and Installation","text":""},{"location":"interacting-with-agents/streamlit-dashboard/#prerequisites","title":"Prerequisites","text":"<p>The streamlit dashboard requires:</p> <ul> <li>Agentic framework with the streamlit extra</li> <li>An active agent server (started with <code>agentic serve</code>)</li> </ul> <p>To install with streamlit support:</p> <pre><code>pip install agentic-framework[streamlit]\n</code></pre>"},{"location":"interacting-with-agents/streamlit-dashboard/#running-the-dashboard","title":"Running the Dashboard","text":"<p>There are two ways to start the dashboard:</p>"},{"location":"interacting-with-agents/streamlit-dashboard/#using-the-cli","title":"Using the CLI","text":"<p>The simplest way to launch the dashboard is through the CLI:</p> <pre><code># Start the Streamlit UI \nagentic streamlit\n\n# If you want to start both the agent server and dashboard together\nagentic serve examples/basic_agent.py &amp; agentic streamlit\n</code></pre>"},{"location":"interacting-with-agents/streamlit-dashboard/#usage-guide","title":"Usage Guide","text":""},{"location":"interacting-with-agents/streamlit-dashboard/#agent-selection","title":"Agent Selection","text":"<ol> <li>Choose an agent from the dropdown</li> <li>The dashboard will display a chat interface with the selected agent</li> <li>You can switch between agents at any time</li> </ol>"},{"location":"interacting-with-agents/streamlit-dashboard/#chatting-with-agents","title":"Chatting with Agents","text":"<ol> <li>Enter your query in the input field at the bottom</li> <li>View agent responses and tool usage in the main chat area</li> <li>Agent responses support Markdown for rich formatting</li> </ol>"},{"location":"interacting-with-agents/streamlit-dashboard/#customizing-the-dashboard","title":"Customizing the Dashboard","text":"<p>The dashboard can be customized in several ways:</p>"},{"location":"interacting-with-agents/streamlit-dashboard/#theming","title":"Theming","text":"<p>Customize the dashboard appearance by creating a <code>.streamlit/config.toml</code> file with your theme preferences:</p> <pre><code>[theme]\nprimaryColor = \"#FF4B4B\"\nbackgroundColor = \"#0E1117\"\nsecondaryBackgroundColor = \"#262730\"\ntextColor = \"#FAFAFA\"\nfont = \"sans serif\"\n</code></pre>"},{"location":"interacting-with-agents/streamlit-dashboard/#custom-agent-views","title":"Custom Agent Views","text":"<p>You can develop custom views for specific agent types by extending the Streamlit app:</p> <ol> <li>Create a new Python file that imports the base dashboard</li> <li>Override the <code>render_agent_view</code> function</li> <li>Add your custom visualization or interaction elements</li> </ol> <pre><code>from agentic.streamlit.app import dashboard_app, render_agent_view\n\ndef custom_agent_view(agent_name, agent_data):\n    # Your custom rendering logic here\n    st.write(f\"Custom view for {agent_name}\")\n    # Add visualizations, metrics, etc.\n\n# Register your custom view\ndashboard_app.add_agent_view(\"MyCustomAgent\", custom_agent_view)\n</code></pre>"},{"location":"interacting-with-agents/streamlit-dashboard/#integration-with-nextjs-dashboard","title":"Integration with Next.js Dashboard","text":"<p>The Streamlit dashboard can be used alongside the Next.js dashboard, with each offering different advantages:</p> <ul> <li>Streamlit: Quick prototyping, data visualization, simpler setup</li> <li>Next.js: More polished UI, better performance with large histories, customizable layouts</li> </ul> <p>To use both interfaces:</p> <ol> <li>Start the Agentic agent server (<code>agentic serve</code>)</li> <li>Start the Streamlit dashboard (<code>agentic streamlit</code>)</li> <li>Start the Next.js dashboard (<code>agentic dashboard start</code>)</li> </ol>"},{"location":"interacting-with-agents/streamlit-dashboard/#troubleshooting","title":"Troubleshooting","text":"<p>Common issues and solutions:</p> <ul> <li>Connection errors: Ensure the agent server is running and accessible</li> <li>Missing agents: Verify agent registration in the server logs</li> <li>Display issues: Check Streamlit version compatibility</li> <li>Performance problems: Reduce history retention for long-running agents</li> </ul>"},{"location":"interacting-with-agents/streamlit-dashboard/#technical-details","title":"Technical Details","text":"<p>The Streamlit dashboard connects to agents through the Agentic API server, using:</p> <ul> <li>Server-sent events (SSE) for real-time updates</li> <li>Asynchronous HTTP requests for agent operations</li> <li>Local state management for UI state</li> </ul>"},{"location":"tools/","title":"Tools","text":"<p>Tools are the fundamental way that your agent gets access to the world around it. Tools can literally do anything - query any data or take any action - that you can think of.</p> <p>It is tempting to think of tools the way we think about libraries that we use in traditional code, but this is a mistake. In fact tools are the key component in the AI to computer interface.  They determine how well the LLM can interact with the world, and the fidelity with which your agent can perceive the world around it. Tools have a huge impact on the efficacy of agents, and building agents often involves a lot of time working on tools (although we are getting better \"off the shelf\" tools all the time.)</p> <p>At root, tools are exposing functions to your Agent. Using the tool calling protocol developed by OpenAI, your agent elects to call tools by generating a text block in its output, and this output is parsed by the framework and turned into the actual function call.</p> <p>Side node: The smolagents library from Huggingface promotes the idea of using  CodeAgents instead of tool calling. Some researchers have found that having your agent write code - on demand - to call functions elicits superior results than traditional tool calling. It's certainly an intriguing notion, and one that we are testing presently.</p> <p>Agentic supports providing tool functions as:</p> <ul> <li>Simple functions</li> <li>Class instance methods</li> <li>Langchain tools</li> <li>Model Context Protocol (from Anthropic) tools</li> <li>Other Agents</li> </ul> <p>Here are a few examples:</p> <pre><code>def simple_function(arg1: int, arg2: int) -&gt;:\n    \"\"\" Multiplies two numbers by a mystery factor \"\"\"\n\n    return arg1 * arg2 * 23\n\nclass FileReaderTool:\n    def get_tools(self) -&gt; list[Callable]:\n        return [\n            self.read_file,\n            self.write_file,\n        ]\n\n    def read_file(self, path: str) -&gt; str:\n        \"\"\" Returns the file at the given path \"\"\"\n        return open(path).read()\n\n    def write_file(self, path: str, content: str) -&gt; str:\n        \"\"\" Writes the provided content to the indicated path \"\"\"\n        with open(path, \"w\") as f:\n            f.write(content)\n        return \"The file was written\"\n\nagent = Agent(\n    ...\n    tools = [simple_function, FileReaderTool()]\n)\n</code></pre> <p>Note that the docstring is required to describe each function.</p> <p>Here are some rules/guidelines for writing good tools:</p> <ul> <li>Generally we find classes and methods are a more useful form than bare functions. There aren't a lot of bare functions that are super helpful tools.</li> <li>Using classes and methods means that you can keep state in your tool (via <code>self</code>) and share it between function calls.</li> <li>The name of the function, the docstring, and the parameter names are all passed to the LLM. Function names should very clearly explain the purpose of the function.</li> <li>You can describe parameter usage (possible values, etc...) in the docstring, but often its enough to just have good parameter names.</li> <li>Try to avoid super generic function names like <code>read_file</code>, and consider prefixing  functions with a namespace, like <code>github_read_file</code>.</li> </ul> <p>Although you can always use \"plain functions\" for tools, Agentic has some special support for particular tool patterns.</p> <p>ThreadContext</p> <p>When your agent is started, a <code>ThreadContext</code> object is created and preserved through the lifetime of the run session. This object can hold arbitrary state that your agent can use during the run. Tool functions just need to define a parameter called <code>thread_context</code> to receive the object when they are invoked:</p> <pre><code>    def hello_func(self, thread_context: ThreadContext, message):\n        print(message)\n        print(\"I am running in agent: \", thread_context.agent.name)\n</code></pre> <p>ThreadContext also offers various utility methods for getting access to system services.</p>"},{"location":"tools/#tool-return-types","title":"Tool return types","text":"<p>The most common tool simply returns a string which is provided to the LLM as the \"anwer\" to the tool call.</p> <p>However, tools can generally return any kind of object as long as it can be serialized into a string. In particular dicts and lists of dicts will be automatically serialized as JSON which most LLMs understand quite well.</p>"},{"location":"tools/#configuration-and-secrets","title":"Configuration and Secrets","text":"<p>It is very common for tools to need some configuration or credentials in order to operate. Agentic tries to provide some framework support to cover the most common cases:</p> <pre><code>- For config, take parameters to the `__init__` function for your tool class\n- Configure secrets in the environment, but use `thread_context` to access them\n- Described required secrets by implementing the `required_secrets` method\n</code></pre> <p>Here is an example from the TavilyTool (for web search):</p> <pre><code>class TavilySearchTool:\n    def __init__(self, api_key: str = None):\n        self.api_key = api_key\n\n    def required_secrets(self) -&gt; dict[str, str]:\n        return {\"TAVILY_API_KEY\": \"Tavily API key\"}\n\n    async def query_for_news(\n        self, thread_context: ThreadContext, query: str, days_back: int = 1\n    ) -&gt; pd.DataFrame | PauseForInputResult:\n        \"\"\"Returns the latest headlines on the given topic.\"\"\"\n\n        api_key = thread_context.get_secret(\"TAVILY_API_KEY\", self.api_key)\n        ...\n</code></pre> <p>You can pass the API key to the init function, but more likely you want to configure that  key in your environment. By implementing <code>required_secrets</code> you tell the framework that your tool needs some credentials, and the framework will check that they are set, or prompt the user to supply them.</p> <p>Once your tool function is called (like 'query_for_news') then you can retrieve the secrets from the ThreadContext. Look at Agentic's secrets system for a description of how secrets are managed.</p>"},{"location":"tools/#using-environment-configuration","title":"Using environment configuration","text":"<p>In addition to secrets, you can store plaintext settings in your enviroment as well. Add a setting with the CLI:</p> <pre><code>agentic set &lt;setting1&gt; &lt;value1&gt;\n</code></pre> <p>and access it in your tool via <code>thread_context.get</code>.</p>"},{"location":"tools/#implementing-human-in-the-loop","title":"Implementing Human-in-the-Loop","text":"<p>Sometimes your tool will need some info from the human operator, and so your agent will need to pause to wait for that input. You can achieve this with the <code>PauseForInputResult</code> class:</p> <pre><code>from agentic.events import PauseForInputResult\n\n    def get_favorite_tv_show(self, thread_context):\n        fave_tv = thread_context.get_setting(\"tv_show\")\n        if fave_tv is None:\n            return PauseForInputResult({\"tv_show\": \"Please indicate your favorite TV Show\"})\n        else:\n            thread_context.set_setting(\"tv_show\", fave_tv) # remember persistently\n        return f\"Ok, getting your favorite espiodes from {fave_tv}\"\n</code></pre> <p>The first time your function is called it determines that the required value is missing, so it returns the <code>PauseForInputResult</code> with the missing key and a message describing what it needs. The message will be shown to the user, and their response will be automatically set in the <code>thread_context</code> using the indicated key. Then your function will be invoked again, but this time the setting should be available. You can choose to persist the value so that the human doesn't get interrupted again on the next run, via <code>thread_context.set_setting</code>. </p> <p>If you want your agent to request \"human input\" directly, there is a convenience <code>HumanInterruptTool</code> available.</p>"},{"location":"tools/#generating-events-logging","title":"Generating Events / Logging","text":"<p>Remember that when you agent is running, it emits a stream of well-typed events. It is possible for tool functions to also generate events. In this case these events will be emitted by your agent, but they won't be revealed to the LLM. Only the actual return value from your function is returned to the LLM.</p> <p>A classic use case is generating logging events from a function:</p> <pre><code>    def long_running_function(self, thread_context) -&gt; str:\n        \"\"\" Runs a long operation and returns the result. \"\"\"\n        for x in range():\n            yield ToolResult(thread_context.agent_name, \"long_running_function\", f\"working on row {x})\n            ... do some work\n\n        return \"The work is done! Thanks for waiting.\"\n</code></pre> <p>Building the event is toilsome, so <code>thread_context</code> has a convenience method:</p> <pre><code>yield thread_context.log(\"Something interesting happened: \", param2, param2)\n</code></pre> <p>This builds and returns the <code>ToolResult</code> event for you.</p> <p>Note that this style works for synchronous functions, but not async. In the async case you need to yield the return value:</p> <pre><code>    async def long_running_function(self) -&gt; str:\n        \"\"\" Runs a long operation and returns the result. \"\"\"\n        for x in range():\n            yield thread_context.log(f\"working on row {x})\n            ... do some work\n\n        yield \"The work is done! Thanks for waiting.\"\n</code></pre> <p>The generator is the right approach for true long-running tools, because otherwise your agent cannot emit any status info while the function is running. However, for short-running functions that still want to do logging, it is annoying to have to implement a generator.</p> <p>So for convenience, you can log into the <code>thread_context</code> instead:</p> <pre><code>    def my_func_with_logging(self, thread_context: ThreadContext) -&gt; str:\n        \"\"\" An interesting functions. \"\"\"\n        for x in range():\n            thread_context.log(f\"working on row {x})\n            ... do some work\n\n        return \"The work is done! Thanks for waiting.\"\n</code></pre> <p>Note that we didn't <code>yield</code> the log object. After your function returns, the system will  automatically publish the <code>ToolResult</code> events from any messages logged by your function,  and then proceed to process the function result.</p> <p>Adding tools dynamically</p> <p>You can add a tool to an agent at any time:</p> <pre><code>agent.add_tool(tool)\n</code></pre> <p>and it will be availabe to the agent the next time it runs.</p>"},{"location":"tools/building-tools/","title":"Building Tools","text":"<p>This guide will walk you through the process of creating your own tools for the agentic framework. While you can always use basic functions as tools, creating a proper tool class with the right structure provides better integration with the framework and enables more advanced features.</p>"},{"location":"tools/building-tools/#getting-started","title":"Getting Started","text":"<p>To create a new tool, you'll need to:</p> <ol> <li>Install the agentic framework</li> <li>Set up a project with <code>agentic init</code></li> <li>Create a new tool file in the tools directory</li> <li>Register your tool with the framework</li> <li>Implement the required functions</li> </ol> <p>Let's walk through these steps in detail.</p>"},{"location":"tools/building-tools/#1-installation","title":"1. Installation","text":"<p>If you haven't already installed the agentic framework, do so with pip. It is best practice to create a new virtual environment for your project:</p> <pre><code>pip install uv\nuv venv  --python 3.12\nsource .venv/bin/activate\n\nuv pip install \"agentic-framework[all]\"\n</code></pre>"},{"location":"tools/building-tools/#2-project-setup","title":"2. Project Setup","text":"<p>Create a new project or navigate to your existing project directory and initialize it with agentic::</p> <pre><code>agentic init .\n</code></pre> <p>This will create the necessary directory structure, including a <code>tools</code> directory where your custom tools will live.</p>"},{"location":"tools/building-tools/#3-creating-a-tool-file","title":"3. Creating a Tool File","text":"<p>Navigate to the <code>tools</code> directory and create a new Python file for your tool. For example, if you're creating a weather tool:</p> <pre><code>cd tools\ntouch weather_tool.py\n</code></pre>"},{"location":"tools/building-tools/#4-basic-tool-structure","title":"4. Basic Tool Structure","text":"<p>Here's the basic structure for a tool:</p> <pre><code>from typing import Callable, Dict, Optional\nfrom agentic.tools.base import BaseAgenticTool\nfrom agentic.tools.utils.registry import tool_registry, Dependency, ConfigRequirement\nfrom agentic.common import ThreadContext\n\n@tool_registry.register(\n    name=\"YourToolName\",\n    description=\"A clear description of what your tool does\",\n    dependencies=[],  # Any pip packages your tool depends on\n    config_requirements=[],  # Any required configuration settings\n)\nclass YourTool(BaseAgenticTool):\n    \"\"\"Detailed description of your tool class.\"\"\"\n\n    def __init__(self, param1: str = None, param2: str = \"default\"):\n        \"\"\"Initialize your tool with any necessary parameters.\"\"\"\n        self.param1 = param1\n        self.param2 = param2\n\n    def get_tools(self) -&gt; list[Callable]:\n        \"\"\"Return a list of functions that will be exposed to the agent.\"\"\"\n        return [\n            self.your_function,\n            # Add more functions here\n        ]\n\n    def your_function(self, thread_context: ThreadContext, param: str) -&gt; str:\n        \"\"\"\n        A function that the agent can call.\n\n        Args:\n            thread_context: Execution context for accessing secrets and settings\n            param: Description of parameter\n\n        Returns:\n            Result of the operation\n        \"\"\"\n        # Implement your functionality here\n        return f\"Processed {param} with {self.param1}\"\n</code></pre>"},{"location":"tools/building-tools/#tool-registry-decorator","title":"Tool Registry Decorator","text":"<p>The <code>@tool_registry.register</code> decorator registers your tool with the framework and provides important metadata:</p> <pre><code>@tool_registry.register(\n    name=\"YourToolName\",           # Name of your tool\n    description=\"Description\",     # Description of what your tool does\n    dependencies=[                 # External packages required by your tool\n        Dependency(\n            name=\"package-name\",\n            version=\"1.0.0\",\n            type=\"pip\",\n        ),\n    ],\n    config_requirements=[          # Configuration settings required by your tool\n        ConfigRequirement(\n            key=\"API_KEY_NAME\",\n            description=\"Description of the setting\",\n            required=True,         # Whether this setting is required\n        ),\n    ],\n)\n</code></pre>"},{"location":"tools/building-tools/#required-methods","title":"Required Methods","text":"<p>Every tool must implement:</p> <ol> <li><code>__init__</code>: Initialize the tool with any necessary parameters</li> <li><code>get_tools</code>: Return a list of callable functions that will be exposed to the agent</li> </ol>"},{"location":"tools/building-tools/#optional-methods","title":"Optional Methods","text":"<p>Common optional functions include:</p> <pre><code>def required_secrets(self) -&gt; Dict[str, str]:\n    \"\"\"Define secrets that this tool requires.\"\"\"\n    return {\n        \"API_KEY_NAME\": \"Description of the API key\",\n        \"OTHER_SECRET\": \"Description of other secret\",\n    }\n\ndef test_credential(self, cred: str, secrets: Dict[str, str]) -&gt; Optional[str]:\n    \"\"\"\n    Test that the given credential secrets are valid.\n    Return None if valid, otherwise return an error message.\n    \"\"\"\n    # Validate credentials\n    api_key = secrets.get(\"API_KEY_NAME\")\n    if not api_key:\n        return \"API key is missing\"\n    # Test the API key\n    return None  # Return None if valid\n</code></pre>"},{"location":"tools/building-tools/#advanced-features","title":"Advanced Features","text":""},{"location":"tools/building-tools/#asynchronous-methods","title":"Asynchronous Methods","text":"<p>You can create asynchronous functions for operations that involve I/O or network requests:</p> <pre><code>async def fetch_data(self, thread_context: ThreadContext, query: str) -&gt; Dict[str, any]:\n    \"\"\"\n    Asynchronously fetch data based on the query.\n\n    Args:\n        thread_context: Execution context\n        query: Search query\n\n    Returns:\n        Dictionary containing the results\n    \"\"\"\n    # Async implementation\n    # You can use httpx, aiohttp, etc. for async HTTP requests\n\n    return {\"results\": [\"data1\", \"data2\"]}\n</code></pre>"},{"location":"tools/building-tools/#handling-authentication","title":"Handling Authentication","text":"<p>Tools often need API keys or other credentials. You can get these from the ThreadContext:</p> <pre><code>def authenticated_function(self, thread_context: ThreadContext, param: str) -&gt; str:\n    \"\"\"Method that requires authentication.\"\"\"\n    # Get API key from secrets or instance variable\n    api_key = thread_context.get_secret(\"API_KEY_NAME\", self.api_key)\n\n    # If no API key is available, request it from the user\n    if not api_key:\n        from agentic.events import PauseForInputResult\n        return PauseForInputResult(\n            {\"API_KEY_NAME\": \"Please provide your API key\"}\n        )\n\n    # Use the API key for authentication\n    return \"Authenticated operation completed\"\n</code></pre>"},{"location":"tools/building-tools/#progress-reporting","title":"Progress Reporting","text":"<p>For long-running operations, you can report progress using generators:</p> <pre><code>def long_operation(self, thread_context: ThreadContext) -&gt; str:\n    \"\"\"Perform a long-running operation with progress updates.\"\"\"\n    total_steps = 10\n\n    for step in range(total_steps):\n        # Perform some work...\n\n        # Report progress\n        yield thread_context.log(f\"Step {step+1}/{total_steps} completed\")\n\n    return \"Operation completed successfully\"\n</code></pre>"},{"location":"tools/building-tools/#registering-your-tool-in-the-framework","title":"Registering Your Tool in the Framework","text":"<p>After creating your tool, you need to register it in the framework's tool registry. This happens automatically when your tool is loaded, thanks to the <code>@tool_registry.register</code> decorator.</p>"},{"location":"tools/building-tools/#example-building-a-simple-weather-tool","title":"Example: Building a Simple Weather Tool","text":"<p>Here's a complete example of a simple weather tool:</p> <pre><code>from typing import Callable, Dict, Optional\nimport requests\n\nfrom agentic.tools.base import BaseAgenticTool\nfrom agentic.tools.utils.registry import tool_registry, Dependency\nfrom agentic.common import ThreadContext\n\n@tool_registry.register(\n    name=\"SimpleWeatherTool\",\n    description=\"A tool for getting basic weather information\",\n    dependencies=[\n        Dependency(\n            name=\"requests\",\n            version=\"2.28.1\",\n            type=\"pip\",\n        ),\n    ],\n)\nclass SimpleWeatherTool(BaseAgenticTool):\n    \"\"\"A simple tool for fetching weather data.\"\"\"\n\n    def __init__(self, api_key: str = None):\n        self.api_key = api_key\n\n    def required_secrets(self) -&gt; Dict[str, str]:\n        return {\n            \"WEATHER_API_KEY\": \"API key for accessing weather data\"\n        }\n\n    def get_tools(self) -&gt; list[Callable]:\n        return [\n            self.get_current_weather,\n        ]\n\n    def get_current_weather(\n        self, \n        thread_context: ThreadContext, \n        city: str, \n        units: str = \"metric\"\n    ) -&gt; Dict[str, any]:\n        \"\"\"\n        Get the current weather for a city.\n\n        Args:\n            thread_context: Execution context\n            city: The name of the city\n            units: Units of measurement ('metric' or 'imperial')\n\n        Returns:\n            Weather data for the city\n        \"\"\"\n        # Get API key from secrets or instance variable\n        api_key = thread_context.get_secret(\"WEATHER_API_KEY\", self.api_key)\n\n        # If no API key is available, request it from the user\n        if not api_key:\n            from agentic.events import PauseForInputResult\n            return PauseForInputResult(\n                {\"WEATHER_API_KEY\": \"Please provide your weather API key\"}\n            )\n\n        # Make API request\n        url = f\"https://api.example.com/weather\"\n        params = {\n            \"q\": city,\n            \"units\": units,\n            \"appid\": api_key\n        }\n\n        thread_context.info(f\"Fetching weather data for {city}\")\n\n        try:\n            response = requests.get(url, params=params)\n            response.raise_for_status()\n            data = response.json()\n\n            return {\n                \"city\": city,\n                \"temperature\": data[\"main\"][\"temp\"],\n                \"conditions\": data[\"weather\"][0][\"description\"],\n                \"humidity\": data[\"main\"][\"humidity\"],\n                \"wind_speed\": data[\"wind\"][\"speed\"]\n            }\n        except Exception as e:\n            thread_context.error(f\"Error fetching weather data: {str(e)}\")\n            return {\"error\": f\"Failed to fetch weather data: {str(e)}\"}\n</code></pre>"},{"location":"tools/building-tools/#testing-your-tool","title":"Testing Your Tool","text":"<p>It's important to test your tool to ensure it works correctly. You can create a simple script to test your tool:</p> <pre><code>from agentic.common import Agent\nfrom your_tools import YourTool\n\n# Create an instance of your tool\nyour_tool = YourTool()\n\n# Create an agent with your tool\nagent = Agent(\n    name=\"TestAgent\",\n    tools=[your_tool]\n)\n\n# Test your agent with a prompt that will use your tool\nresult = agent.run(\"Use YourTool to perform a test operation\")\nprint(result)\n</code></pre>"},{"location":"tools/building-tools/#best-practices","title":"Best Practices","text":"<ol> <li>Clear Documentation: Write comprehensive docstrings for your tool class and all its functions</li> <li>Descriptive Names: Use clear, descriptive names for your tool and its functions</li> <li>Type Hints: Always use proper type hints for parameters and return values</li> <li>Error Handling: Handle errors gracefully and return informative error messages</li> <li>Async for I/O: Use async functions for I/O operations to avoid blocking</li> <li>Progress Reporting: For long-running operations, report progress using generators</li> <li>Secrets Management: Use the required_secrets function to declare required secrets</li> <li>Testing: Write tests for your tool to ensure it works correctly</li> </ol> <p>By following these guidelines, you can create powerful, reliable tools that will enhance your agents' capabilities and provide a seamless experience for users.</p>"},{"location":"tools/tool-library/","title":"Tool Library","text":"<p>Agentic comes with a comprehensive set of built-in tools to help your agents interact with various services and data sources. This library makes it easy to add powerful capabilities to your agents without writing complex code.</p>"},{"location":"tools/tool-library/#available-tools","title":"Available Tools","text":"Tool Description AirbnbCalendarTool Access and analyze Airbnb calendar data from iCal feeds AuthorizedRestApiTool Make authenticated REST API calls with various auth methods BrowserUseTool Automate browser interactions with a smart agent DatabaseTool Connect to and query SQL databases DuckDuckGoTool Search the web using DuckDuckGo FileDownloadTool Download files from URLs GithubTool Interact with GitHub repositories and APIs GoogleNewsTool Access Google News for headlines and articles HumanInterruptTool Pause execution to request human input IMAPTool Access email inboxes using IMAP protocol LinkedinDataTool Retrieve data from LinkedIn profiles and companies MCPTool Universal wrapper for Model Control Protocol (MCP) servers MeetingBaasTool Manage video meetings, record transcripts, and generate summaries ImageGeneratorTool Generate images using OpenAI's image generation API PlaywrightTool Browser automation using Playwright RAGTool Manage and query knowledge bases using Retrieval Augmented Generation RestApiTool Make REST API calls with comprehensive options ScaleSerpBrowserTool Web browsing and search using SCALESERP API TavilySearchTool Web search using Tavily's search engine TextToSpeechTool Convert text to speech with different voices WeatherTool Get current, forecast, and historical weather information"},{"location":"tools/tool-library/#how-to-use-tools","title":"How to Use Tools","text":"<p>Tools can be added to your agent by passing them to the <code>tools</code> parameter when creating an agent:</p> <pre><code>from agentic.common import Agent\nfrom agentic.tools import GoogleNewsTool, WeatherTool\n\nagent = Agent(\n    name=\"News and Weather Agent\",\n    instructions=\"You are a helpful assistant that provides news and weather information.\",\n    tools=[WeatherTool(), GoogleNewsTool()]\n)\n</code></pre> <p>Some tools require API keys or other configuration. These are typically passed during initialization:</p> <pre><code>from agentic.tools import GithubTool\n\ngithub_tool = GithubTool(api_key=\"your_github_token\", default_repo=\"owner/repo\")\n</code></pre> <p>For more information on creating your own tools, see Tools.</p>"},{"location":"tools/tool-library/airbnb-calendar-tool/","title":"AirbnbCalendarTool","text":"<p>The <code>AirbnbCalendarTool</code> enables agents to access and analyze Airbnb calendar data from iCal feeds. This tool helps property hosts manage bookings, check availability, calculate occupancy rates, and identify blocked dates.</p>"},{"location":"tools/tool-library/airbnb-calendar-tool/#features","title":"Features","text":"<ul> <li>View upcoming bookings and events</li> <li>Check availability for specific date ranges</li> <li>Generate booking statistics and occupancy rates</li> <li>List blocked/unavailable dates</li> </ul>"},{"location":"tools/tool-library/airbnb-calendar-tool/#authentication","title":"Authentication","text":"<p>Requires an Airbnb calendar URL (iCal format) which can be stored in Agentic's secrets system as <code>AIRBNB_CALENDAR_URL</code>. This URL can be found in your Airbnb host dashboard under Calendar &gt; Availability &gt; Connect to another website.</p>"},{"location":"tools/tool-library/airbnb-calendar-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/airbnb-calendar-tool/#list_events","title":"list_events","text":"<pre><code>async def list_events(thread_context: ThreadContext, start_date: Optional[str] = None, end_date: Optional[str] = None) -&gt; str\n</code></pre> <p>List all events/bookings in the calendar within the specified date range.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>start_date (Optional[str])</code>: Start date in ISO format (YYYY-MM-DD)</li> <li><code>end_date (Optional[str])</code>: End date in ISO format (YYYY-MM-DD)</li> </ul> <p>Returns: A JSON string containing the events in the calendar.</p>"},{"location":"tools/tool-library/airbnb-calendar-tool/#check_availability","title":"check_availability","text":"<pre><code>async def check_availability(thread_context: ThreadContext, start_date: Optional[str] = None, end_date: Optional[str] = None) -&gt; str\n</code></pre> <p>Check if the property is available for a specific date range.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>start_date (Optional[str])</code>: Start date in ISO format (YYYY-MM-DD)</li> <li><code>end_date (Optional[str])</code>: End date in ISO format (YYYY-MM-DD)</li> </ul> <p>Returns: A JSON string indicating availability and any conflicts.</p>"},{"location":"tools/tool-library/airbnb-calendar-tool/#get_booking_stats","title":"get_booking_stats","text":"<pre><code>async def get_booking_stats(thread_context: ThreadContext, start_date: Optional[str] = None, end_date: Optional[str] = None) -&gt; str\n</code></pre> <p>Get booking statistics for a specified date range.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>start_date (Optional[str])</code>: Start date in ISO format (YYYY-MM-DD)</li> <li><code>end_date (Optional[str])</code>: End date in ISO format (YYYY-MM-DD)</li> </ul> <p>Returns: A JSON string containing booking statistics including total days, booked days, booking count, and occupancy rate.</p>"},{"location":"tools/tool-library/airbnb-calendar-tool/#get_blocked_dates","title":"get_blocked_dates","text":"<pre><code>async def get_blocked_dates(thread_context: ThreadContext, start_date: Optional[str] = None, end_date: Optional[str] = None) -&gt; str\n</code></pre> <p>Get a list of blocked/unavailable dates.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>start_date (Optional[str])</code>: Start date in ISO format (YYYY-MM-DD)</li> <li><code>end_date (Optional[str])</code>: End date in ISO format (YYYY-MM-DD)</li> </ul> <p>Returns: A JSON string containing a sorted list of blocked dates.</p>"},{"location":"tools/tool-library/airbnb-calendar-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import AirbnbCalendarTool\n\n# Create an agent with Airbnb calendar capabilities\nairbnb_agent = Agent(\n    name=\"Airbnb Calendar Assistant\",\n    instructions=\"You help manage Airbnb property calendars and bookings.\",\n    tools=[AirbnbCalendarTool()]\n)\n\n# Use the agent\nresponse = airbnb_agent &lt;&lt; \"Check if my property is available from June 15, 2025 to June 20, 2025\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/authorized-rest-api-tool/","title":"AuthorizedRestApiTool","text":"<p>The <code>AuthorizedRestApiTool</code> is a specialized version of <code>RestApiTool</code> that provides a simplified way to make authenticated REST API calls. This tool streamlines authentication handling, making it ideal for working with APIs that require consistent authentication across multiple requests.</p>"},{"location":"tools/tool-library/authorized-rest-api-tool/#features","title":"Features","text":"<ul> <li>Simplified authentication setup</li> <li>Support for Bearer tokens, Basic auth, API keys in parameters, and custom headers</li> <li>All the capabilities of the base REST API tool</li> <li>Automatic secret retrieval from Agentic's secret store</li> </ul>"},{"location":"tools/tool-library/authorized-rest-api-tool/#initialization","title":"Initialization","text":"<pre><code>def __init__(token_type: str, token_var: str, token_name: str = \"Bearer\")\n</code></pre> <p>Parameters:</p> <ul> <li><code>token_type (str)</code>: Authentication type, one of \"bearer\", \"basic\", \"parameter\", or \"header\"</li> <li><code>token_var (str)</code>: The name of the secret variable that contains the token value</li> <li><code>token_name (str)</code>: The name used with the token (varies by auth method)</li> </ul>"},{"location":"tools/tool-library/authorized-rest-api-tool/#authentication-types","title":"Authentication Types","text":"<p>The tool supports the following authentication methods:</p> <ol> <li> <p>Bearer Token:    <code>python    AuthorizedRestApiTool(\"bearer\", \"API_KEY_SECRET_NAME\")</code>    Adds an <code>Authorization: Bearer &lt;token&gt;</code> header.</p> </li> <li> <p>Basic Auth:    <code>python    AuthorizedRestApiTool(\"basic\", \"BASIC_AUTH_SECRET\")</code>    For basic auth, the secret should be in the format <code>username:password</code>.</p> </li> <li> <p>Parameter Auth:    <code>python    AuthorizedRestApiTool(\"parameter\", \"API_KEY_SECRET\", \"api_key\")</code>    Adds the token as a query parameter (e.g., <code>?api_key=value</code>).</p> </li> <li> <p>Header Auth:    <code>python    AuthorizedRestApiTool(\"header\", \"API_KEY_SECRET\", \"X-API-Key\")</code>    Adds a custom header with the specified name (e.g., <code>X-API-Key: value</code>).</p> </li> </ol>"},{"location":"tools/tool-library/authorized-rest-api-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/authorized-rest-api-tool/#get_resource","title":"get_resource","text":"<pre><code>async def get_resource(url: str, params: dict = {}, thread_context: ThreadContext = None)\n</code></pre> <p>Performs an HTTP GET request with authentication.</p> <p>Parameters:</p> <ul> <li><code>url (str)</code>: The URL to request</li> <li><code>params (dict)</code>: Query parameters</li> <li><code>thread_context (ThreadContext)</code>: The execution context</li> </ul> <p>Returns: The parsed response based on content type.</p>"},{"location":"tools/tool-library/authorized-rest-api-tool/#post_resource","title":"post_resource","text":"<pre><code>async def post_resource(url: str, content_type: str = \"application/json\", data: str = \"{}\", thread_context: ThreadContext = None)\n</code></pre> <p>Performs an HTTP POST request with authentication.</p> <p>Parameters:</p> <ul> <li><code>url (str)</code>: The URL to request</li> <li><code>content_type (str)</code>: The content type (default: \"application/json\")</li> <li><code>data (str)</code>: Request body</li> <li><code>thread_context (ThreadContext)</code>: The execution context</li> </ul> <p>Returns: The parsed response based on content type.</p>"},{"location":"tools/tool-library/authorized-rest-api-tool/#put_resource","title":"put_resource","text":"<pre><code>async def put_resource(url: str, data: str = \"{}\", thread_context: ThreadContext = None)\n</code></pre> <p>Performs an HTTP PUT request with authentication.</p> <p>Parameters:</p> <ul> <li><code>url (str)</code>: The URL to request</li> <li><code>data (str)</code>: JSON request body</li> <li><code>thread_context (ThreadContext)</code>: The execution context</li> </ul> <p>Returns: The parsed response based on content type.</p>"},{"location":"tools/tool-library/authorized-rest-api-tool/#patch_resource","title":"patch_resource","text":"<pre><code>async def patch_resource(url: str, data: str = \"{}\", thread_context: ThreadContext = None)\n</code></pre> <p>Performs an HTTP PATCH request with authentication.</p> <p>Parameters:</p> <ul> <li><code>url (str)</code>: The URL to request</li> <li><code>data (str)</code>: JSON request body</li> <li><code>thread_context (ThreadContext)</code>: The execution context</li> </ul> <p>Returns: The parsed response based on content type.</p>"},{"location":"tools/tool-library/authorized-rest-api-tool/#delete_resource","title":"delete_resource","text":"<pre><code>async def delete_resource(url: str, thread_context: ThreadContext = None)\n</code></pre> <p>Performs an HTTP DELETE request with authentication.</p> <p>Parameters:</p> <ul> <li><code>url (str)</code>: The URL to request</li> <li><code>thread_context (ThreadContext)</code>: The execution context</li> </ul> <p>Returns: The parsed response based on content type.</p>"},{"location":"tools/tool-library/authorized-rest-api-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import AuthorizedRestApiTool\n\n# Set up the secret first\n# agentic secrets set GITHUB_TOKEN=your_token_here\n\n# Create an agent with authenticated API capability\ngithub_api = AuthorizedRestApiTool(\"bearer\", \"GITHUB_TOKEN\")\napi_agent = Agent(\n    name=\"GitHub API Client\",\n    instructions=\"You can make authenticated API calls to GitHub.\",\n    tools=[github_api]\n)\n\n# Use the agent to get user information\nresponse = api_agent &lt;&lt; \"Get my GitHub profile information from https://api.github.com/user\"\nprint(response)\n\n# Use the agent to list repositories\nresponse = api_agent &lt;&lt; \"List my repositories from https://api.github.com/user/repos\"\nprint(response)\n\n# Using an API key in a parameter\nweather_api = AuthorizedRestApiTool(\"parameter\", \"WEATHER_API_KEY\", \"apikey\")\nweather_agent = Agent(\n    name=\"Weather API Client\",\n    instructions=\"You can get weather data using the Weather API.\",\n    tools=[weather_api]\n)\n\n# Use the agent to get weather data\nresponse = weather_agent &lt;&lt; \"Get the current weather for London from https://api.weatherapi.com/v1/current.json\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/authorized-rest-api-tool/#setting-up-secrets","title":"Setting Up Secrets","text":"<p>Before using the tool, you need to set up your secrets:</p> <pre><code># For GitHub API\nagentic secrets set GITHUB_TOKEN=your_github_token\n\n# For Weather API\nagentic secrets set WEATHER_API_KEY=your_weather_api_key\n</code></pre>"},{"location":"tools/tool-library/authorized-rest-api-tool/#common-api-configurations","title":"Common API Configurations","text":"<ol> <li> <p>GitHub API:    <code>python    AuthorizedRestApiTool(\"bearer\", \"GITHUB_TOKEN\")</code></p> </li> <li> <p>OpenAI API:    <code>python    AuthorizedRestApiTool(\"bearer\", \"OPENAI_API_KEY\")</code></p> </li> <li> <p>RapidAPI:    <code>python    AuthorizedRestApiTool(\"header\", \"RAPIDAPI_KEY\", \"X-RapidAPI-Key\")</code></p> </li> <li> <p>AWS Signature v4:    <code>python    # For AWS, use a custom tool that implements Signature v4 auth    # The AuthorizedRestApiTool is for simpler auth methods</code></p> </li> </ol>"},{"location":"tools/tool-library/authorized-rest-api-tool/#notes","title":"Notes","text":"<ul> <li>The tool automatically retrieves the token value from the agent's secret store</li> <li>If the token is not found, the tool will raise an error</li> <li>The authentication is automatically applied to all requests</li> <li>For different APIs that require different authentications, create multiple instances of the tool</li> <li>The tool inherits all capabilities from RestApiTool</li> <li>For more complex authentication schemes like OAuth 2.0 flows, additional tools may be needed</li> </ul>"},{"location":"tools/tool-library/automatic-tools/","title":"AutomaticTools","text":"<p>The <code>AutomaticTools</code> is a meta-tool that provides dynamic tool discovery and management capabilities. It allows agents to automatically detect, search for, and enable appropriate tools based on user needs.</p>"},{"location":"tools/tool-library/automatic-tools/#features","title":"Features","text":"<ul> <li>Automatically discover available tools from a configured list</li> <li>Search for tools based on purpose or functionality</li> <li>Dynamically enable tools for the agent</li> <li>Support for both tool classes and tool functions</li> </ul>"},{"location":"tools/tool-library/automatic-tools/#methods","title":"Methods","text":""},{"location":"tools/tool-library/automatic-tools/#get_tool_listing","title":"get_tool_listing","text":"<pre><code>async def get_tool_listing() -&gt; list[dict]\n</code></pre> <p>Returns a list of all available tools with their names and descriptions.</p> <p>Returns: A list of dictionaries containing tool names and descriptions.</p>"},{"location":"tools/tool-library/automatic-tools/#search_for_tool","title":"search_for_tool","text":"<pre><code>async def search_for_tool(purpose: str) -&gt; list[str]\n</code></pre> <p>Searches for one or more tools related to the indicated purpose using both semantic search and keyword matching.</p> <p>Parameters: - <code>purpose (str)</code>: The intended purpose or functionality needed</p> <p>Returns: A list of tool names that match the purpose.</p>"},{"location":"tools/tool-library/automatic-tools/#enable_agent_tool","title":"enable_agent_tool","text":"<pre><code>async def enable_agent_tool(tool_name: str, thread_context: ThreadContext) -&gt; str\n</code></pre> <p>Enables a specific tool for the agent to use.</p> <p>Parameters: - <code>tool_name (str)</code>: The name of the tool to enable - <code>thread_context (ThreadContext)</code>: The agent's running context</p> <p>Returns: A status message indicating whether the tool was successfully enabled or suggestions for similar tools.</p>"},{"location":"tools/tool-library/automatic-tools/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import AutomaticTools, WeatherTool, GoogleNewsTool, DatabaseTool\n\n# Create an agent with dynamic tool capabilities\ndynamic_agent = Agent(\n    name=\"Dynamic Assistant\",\n    instructions=\"You are a helpful assistant that can dynamically enable tools as needed.\",\n    tools=[\n        AutomaticTools(\n            tool_classes=[\n                WeatherTool,\n                GoogleNewsTool,\n                DatabaseTool\n            ]\n        )\n    ]\n)\n\n# The agent can now dynamically enable tools based on user needs\nresponse = dynamic_agent &lt;&lt; \"What's the weather like in New York?\"\n# The agent will automatically enable the WeatherTool and use it\n\nresponse = dynamic_agent &lt;&lt; \"Show me the latest tech news\"\n# The agent will automatically enable the GoogleNewsTool and use it\n</code></pre>"},{"location":"tools/tool-library/automatic-tools/#implementation-details","title":"Implementation Details","text":"<p>The AutomaticTools uses several key features:</p> <ol> <li>Tool Registry: Integrates with Agentic's tool registry system for tool discovery</li> <li>Semantic Search: Uses LLM-based semantic search to find relevant tools</li> <li>Keyword Matching: Falls back to keyword matching when semantic search doesn't find matches</li> <li>Dynamic Loading: Can load both tool classes and individual tool functions</li> </ol>"},{"location":"tools/tool-library/automatic-tools/#helper-method","title":"Helper Method","text":"<p>The tool includes a helper method:</p> <ul> <li><code>get_docstring</code>: Extracts documentation from tools</li> </ul>"},{"location":"tools/tool-library/automatic-tools/#notes","title":"Notes","text":"<ul> <li>The tool automatically handles tool discovery and loading</li> <li>It provides intelligent suggestions when requested tools aren't found</li> <li>Supports both class-based tools and function-based tools</li> <li>Integrates with Agentic's tool registry system</li> <li>Can be used to create highly dynamic agents that adapt their capabilities based on user needs </li> </ul>"},{"location":"tools/tool-library/browser-use-tool/","title":"BrowserUseTool","text":"<p>The <code>BrowserUseTool</code> enables intelligent browser automation through LLM-directed interactions. This tool allows agents to navigate websites, perform complex tasks, and extract information by controlling a browser instance.</p>"},{"location":"tools/tool-library/browser-use-tool/#features","title":"Features","text":"<ul> <li>Full browser automation with LLM control</li> <li>Support for authenticated web sessions</li> <li>Visual page navigation and interaction</li> <li>Content extraction and analysis</li> <li>Support for different browser modes (visible or headless)</li> </ul>"},{"location":"tools/tool-library/browser-use-tool/#dependencies","title":"Dependencies","text":"<ul> <li>Requires the <code>playwright</code> and <code>browser-use</code> packages</li> </ul>"},{"location":"tools/tool-library/browser-use-tool/#initialization","title":"Initialization","text":"<pre><code>def __init__(chrome_instance_path: Optional[str] = None, model: str = GPT_4O_MINI)\n</code></pre> <p>Parameters:</p> <ul> <li><code>chrome_instance_path (Optional[str])</code>: Optional path to Chrome executable (to use the user's browser with cookies and state)</li> <li><code>model (str)</code>: LLM model to use for browser automation (default: GPT_4O_MINI)</li> </ul>"},{"location":"tools/tool-library/browser-use-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/browser-use-tool/#run_browser_agent","title":"run_browser_agent","text":"<pre><code>async def run_browser_agent(thread_context: ThreadContext, instructions: str, model: Optional[str] = None) -&gt; list[str|FinishCompletion]\n</code></pre> <p>Execute a set of instructions via browser automation. Instructions can be in natural language.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>instructions (str)</code>: Natural language instructions for what to do with the browser</li> <li><code>model (Optional[str])</code>: Override the default LLM model</li> </ul> <p>Returns: A list containing the history of browsing actions taken and a FinishCompletion event with token usage information.</p>"},{"location":"tools/tool-library/browser-use-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import BrowserUseTool\n\n# Create an agent with browser automation capabilities\nbrowser_agent = Agent(\n    name=\"Web Automator\",\n    instructions=\"You help users navigate websites and perform tasks online.\",\n    tools=[BrowserUseTool()]\n)\n\n# Use the agent with natural language instructions\nresponse = browser_agent &lt;&lt; \"Go to weather.gov, search for the weather in Boston, and tell me the forecast for tomorrow.\"\nprint(response)\n\n# Using a specific Chrome instance (with user cookies/login state)\nchrome_path = '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'  # macOS example\nbrowser_agent = Agent(\n    name=\"Authenticated Browser\",\n    instructions=\"You help automate tasks on websites where the user is already logged in.\",\n    tools=[BrowserUseTool(chrome_instance_path=chrome_path)]\n)\n\nresponse = browser_agent &lt;&lt; \"Go to my Gmail account and summarize the last 3 unread emails\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/browser-use-tool/#browser-paths","title":"Browser Paths","text":"<p>Common paths for the <code>chrome_instance_path</code> parameter:</p> <ul> <li>macOS: <code>/Applications/Google Chrome.app/Contents/MacOS/Google Chrome</code></li> <li>Windows: <code>C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe</code></li> <li>Linux: <code>/usr/bin/google-chrome</code></li> </ul>"},{"location":"tools/tool-library/browser-use-tool/#typical-use-cases","title":"Typical Use Cases","text":"<ul> <li>Automating web research across multiple sources</li> <li>Filling out forms and submitting information</li> <li>Extracting structured data from websites</li> <li>Performing sequences of actions that require login state</li> <li>Testing web applications</li> </ul>"},{"location":"tools/tool-library/database-tool/","title":"DatabaseTool","text":"<p>The <code>DatabaseTool</code> provides a flexible interface for connecting to and querying SQL databases. This tool supports multiple database engines and allows agents to execute SQL queries with proper authentication.</p>"},{"location":"tools/tool-library/database-tool/#features","title":"Features","text":"<ul> <li>Connect to multiple database types (PostgreSQL, MySQL, SQLite, MSSQL)</li> <li>Run arbitrary SQL queries</li> <li>Support for SQL connection strings or CLI-style connection commands</li> <li>Automatic conversion of query results to pandas DataFrames or JSON</li> <li>Safe handling of database credentials</li> </ul>"},{"location":"tools/tool-library/database-tool/#initialization","title":"Initialization","text":"<pre><code>def __init__(connection_string: str = None)\n</code></pre> <p>Parameters:</p> <ul> <li><code>connection_string (str)</code>: Database connection string or CLI-style connection command</li> </ul>"},{"location":"tools/tool-library/database-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/database-tool/#run_database_query","title":"run_database_query","text":"<pre><code>def run_database_query(sql_query: str, thread_context: ThreadContext) -&gt; pd.DataFrame | dict | PauseForInputResult\n</code></pre> <p>Runs a SQL query against a connected database.</p> <p>Parameters:</p> <ul> <li><code>sql_query (str)</code>: The SQL query to execute</li> <li><code>thread_context (ThreadContext)</code>: The execution context with access to secrets</li> </ul> <p>Returns: Query results as a pandas DataFrame (for SELECT queries), or a status message (for other query types).</p>"},{"location":"tools/tool-library/database-tool/#get_database_type","title":"get_database_type","text":"<pre><code>def get_database_type(thread_context: ThreadContext) -&gt; str\n</code></pre> <p>Returns the type and SQL dialect of the connected database.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> </ul> <p>Returns: A string indicating the database type (e.g., \"PostgreSQL\", \"MySQL\", etc.).</p>"},{"location":"tools/tool-library/database-tool/#connection-string-formats","title":"Connection String Formats","text":"<p>The tool supports the following connection string formats:</p>"},{"location":"tools/tool-library/database-tool/#sqlalchemy-connection-strings","title":"SQLAlchemy Connection Strings","text":"<pre><code>postgresql+psycopg2://username:password@host:port/database\nmysql+pymysql://username:password@host:port/database  \nmssql+pymssql://username:password@host:port/database\nsqlite:///path/to/database.db\n</code></pre>"},{"location":"tools/tool-library/database-tool/#cli-style-connection-commands","title":"CLI-Style Connection Commands","text":"<p>PostgreSQL:</p> <pre><code>PGPASSWORD=password psql -h host -p port -U username -d database\n</code></pre> <p>MySQL:</p> <pre><code>mysql -h host -P port -u username -p password -D database\n</code></pre> <p>MSSQL:</p> <pre><code>sqlcmd -S host -U username -P password -d database\n</code></pre>"},{"location":"tools/tool-library/database-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import DatabaseTool\n\n# Connect with a connection string\ndb_tool = DatabaseTool(\"postgresql+psycopg2://user:pass@localhost:5432/mydb\")\n\n# Create an agent with database capabilities\ndb_agent = Agent(\n    name=\"Database Assistant\",\n    instructions=\"You help users query databases and analyze data.\",\n    tools=[db_tool]\n)\n\n# Use the agent to run queries\nresponse = db_agent &lt;&lt; \"Show me the top 5 customers by total order amount\"\nprint(response)\n\n# Or store the connection info in the agent's secrets\n# and let the agent prompt for it when needed\ngeneric_db_agent = Agent(\n    name=\"Database Explorer\",\n    instructions=\"You connect to various databases and run queries.\",\n    tools=[DatabaseTool()]\n)\n\nresponse = generic_db_agent &lt;&lt; \"Connect to our PostgreSQL database and list all tables\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/database-tool/#handling-credentials","title":"Handling Credentials","text":"<p>The tool can access database credentials in multiple ways:</p> <ol> <li>Direct initialization: <code>DatabaseTool(\"connection_string\")</code></li> <li>Environment variables</li> <li>Agentic's secret system: <code>agentic secrets set database_url=\"connection_string\"</code></li> <li>Interactive prompting: The tool will pause and ask for credentials if needed</li> </ol>"},{"location":"tools/tool-library/database-tool/#supported-database-features","title":"Supported Database Features","text":"<ul> <li>SELECT queries return pandas DataFrames for easy data manipulation</li> <li>INSERT, UPDATE, DELETE queries return row counts</li> <li>CREATE, DROP and other DDL statements return success status</li> <li>Transaction support based on the underlying database capabilities</li> <li>Automatic type conversion between SQL and Python types</li> </ul>"},{"location":"tools/tool-library/duckduckgo-tool/","title":"DuckDuckGoTool","text":"<p>The <code>DuckDuckGoTool</code> provides a simple interface to search the web using DuckDuckGo. This tool allows agents to perform web searches without requiring API keys or authentication.</p>"},{"location":"tools/tool-library/duckduckgo-tool/#features","title":"Features","text":"<ul> <li>Free web search without API keys required</li> <li>Multiple search types (text, news, images)</li> <li>Customizable search parameters</li> <li>Region-specific search results</li> <li>SafeSearch filtering options</li> </ul>"},{"location":"tools/tool-library/duckduckgo-tool/#initialization","title":"Initialization","text":"<pre><code>def __init__(region: Optional[str] = \"wt-wt\", safesearch: str = \"moderate\", time: Optional[str] = \"y\", max_results: int = 5, backend: str = \"auto\", source: str = \"text\")\n</code></pre> <p>Parameters:</p> <ul> <li><code>region (Optional[str])</code>: The region for search results (default: \"wt-wt\")</li> <li><code>safesearch (str)</code>: SafeSearch level (\"strict\", \"moderate\", or \"off\") (default: \"moderate\")</li> <li><code>time (Optional[str])</code>: Time range for results (\"d\" for day, \"w\" for week, \"m\" for month, \"y\" for year) (default: \"y\")</li> <li><code>max_results (int)</code>: Maximum number of results to return (default: 5)</li> <li><code>backend (str)</code>: Search backend to use (\"auto\", \"html\", or \"lite\") (default: \"auto\")</li> <li><code>source (str)</code>: Type of search (\"text\", \"news\", or \"images\") (default: \"text\")</li> </ul>"},{"location":"tools/tool-library/duckduckgo-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/duckduckgo-tool/#web_search_with_duckduckgo","title":"web_search_with_duckduckgo","text":"<pre><code>def web_search_with_duckduckgo(query: str, max_results: int = 10, source: Optional[str] = None) -&gt; List[Dict[str, str]]\n</code></pre> <p>Perform web search on DuckDuckGo and return metadata.</p> <p>Parameters:</p> <ul> <li><code>query (str)</code>: The query to search for</li> <li><code>max_results (int)</code>: The number of results to return (default: 10)</li> <li><code>source (Optional[str])</code>: The source to look from (\"text\", \"news\", or \"images\") (default: None, uses the initialized source)</li> </ul> <p>Returns: A list of dictionaries with search results. The structure varies by source type:</p> <ul> <li>Text search: Each result includes <code>snippet</code>, <code>title</code>, and <code>link</code></li> <li>News search: Each result includes <code>snippet</code>, <code>title</code>, <code>link</code>, <code>date</code>, and <code>source</code></li> <li>Image search: Each result includes <code>title</code>, <code>thumbnail</code>, <code>image</code>, <code>url</code>, <code>height</code>, <code>width</code>, and <code>source</code></li> </ul>"},{"location":"tools/tool-library/duckduckgo-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import DuckDuckGoTool\n\n# Create a basic search tool with default settings\nsearch_tool = DuckDuckGoTool()\n\n# Create an agent with search capabilities\nsearch_agent = Agent(\n    name=\"Web Researcher\",\n    instructions=\"You help users find information on the web.\",\n    tools=[search_tool]\n)\n\n# Use the agent for a basic text search\nresponse = search_agent &lt;&lt; \"Find information about renewable energy technologies\"\nprint(response)\n\n# Create a tool for news searches\nnews_search = DuckDuckGoTool(source=\"news\", time=\"d\", max_results=10)\n\n# Create an agent focused on news\nnews_agent = Agent(\n    name=\"News Researcher\",\n    instructions=\"You find and summarize recent news stories.\",\n    tools=[news_search]\n)\n\n# Use the agent for news search\nresponse = news_agent &lt;&lt; \"What are the latest developments in AI regulation?\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/duckduckgo-tool/#additional-options","title":"Additional Options","text":""},{"location":"tools/tool-library/duckduckgo-tool/#region-values","title":"Region Values","text":"<p>The region parameter accepts various region codes, including:</p> <ul> <li>\"wt-wt\" (International)</li> <li>\"us-en\" (United States)</li> <li>\"uk-en\" (United Kingdom)</li> <li>\"ca-en\" (Canada)</li> <li>\"de-de\" (Germany)</li> <li>\"fr-fr\" (France)</li> <li>\"jp-jp\" (Japan)</li> </ul>"},{"location":"tools/tool-library/duckduckgo-tool/#backend-options","title":"Backend Options","text":"<ul> <li>\"auto\": Automatically selects the best backend</li> <li>\"html\": Uses the HTML scraping backend</li> <li>\"lite\": Uses the lighter API backend (may return fewer results)</li> </ul>"},{"location":"tools/tool-library/duckduckgo-tool/#source-types","title":"Source Types","text":"<ul> <li>\"text\": Standard web search results</li> <li>\"news\": News article results</li> <li>\"images\": Image search results</li> </ul>"},{"location":"tools/tool-library/file-download-tool/","title":"FileDownloadTool","text":"<p>The <code>FileDownloadTool</code> provides functionality for downloading files and content from URLs. This tool allows agents to retrieve files from the web and either save them locally or directly access their contents.</p>"},{"location":"tools/tool-library/file-download-tool/#features","title":"Features","text":"<ul> <li>Download files from URLs and save them locally</li> <li>Retrieve file contents without saving to disk</li> <li>Extract text content from HTML pages</li> <li>Handle redirects and various content types</li> </ul>"},{"location":"tools/tool-library/file-download-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/file-download-tool/#download_url_as_file","title":"download_url_as_file","text":"<pre><code>async def download_url_as_file(url: str, file_name_hint: str = \"\") -&gt; str\n</code></pre> <p>Downloads a file from a URL and stores it locally.</p> <p>Parameters:</p> <ul> <li><code>url (str)</code>: The URL of the file to download</li> <li><code>file_name_hint (str)</code>: Optional name for the saved file (default: extracted from URL)</li> </ul> <p>Returns: The file name of the saved file, or an error message if the download failed.</p>"},{"location":"tools/tool-library/file-download-tool/#download_file_content","title":"download_file_content","text":"<pre><code>def download_file_content(url: str, limit: int = 4000) -&gt; str\n</code></pre> <p>Downloads a file from the web and returns its contents directly.</p> <p>Parameters:</p> <ul> <li><code>url (str)</code>: The URL of the file to download</li> <li><code>limit (int)</code>: Maximum number of characters to return (default: 4000)</li> </ul> <p>Returns: The content of the downloaded file, or an error message if the download failed.</p>"},{"location":"tools/tool-library/file-download-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import FileDownloadTool\n\n# Create an agent with file downloading capabilities\ndownload_agent = Agent(\n    name=\"File Downloader\",\n    instructions=\"You help users download files and extract content from web URLs.\",\n    tools=[FileDownloadTool()]\n)\n\n# Use the agent to download a file\nresponse = download_agent &lt;&lt; \"Download the file from https://www.iana.org/reports/2014/transition-plan-201404.pdf\"\nprint(response)\n\n# Use the agent to get content directly\nresponse = download_agent &lt;&lt; \"Get the content from https://www.iana.org/about\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/file-download-tool/#helper-methods","title":"Helper Methods","text":"<p>The tool provides these hidden helper methods:</p> <ul> <li><code>get_last_path_component</code>: Extracts filename from URL path</li> <li><code>_download_url_as_file</code>: Internal async method that handles the actual download</li> </ul>"},{"location":"tools/tool-library/file-download-tool/#notes","title":"Notes","text":"<ul> <li>HTML content is automatically converted to plain text using html2text</li> <li>The tool follows redirects when downloading files</li> <li>File downloads are handled asynchronously</li> <li>For HTML content, a limit parameter controls how much text is returned</li> <li>If a filename isn't specified, it will be extracted from the URL</li> </ul>"},{"location":"tools/tool-library/github-tool/","title":"GithubTool","text":"<p>The <code>GithubTool</code> provides comprehensive access to GitHub operations and data. This tool allows agents to interact with GitHub repositories, issues, pull requests, and more through the GitHub API.</p>"},{"location":"tools/tool-library/github-tool/#features","title":"Features","text":"<ul> <li>Repository management (create, delete, clone, etc.)</li> <li>Issue and pull request management</li> <li>Code search and repository content browsing</li> <li>User information retrieval</li> <li>Git operations (commit, push, pull, branch management)</li> </ul>"},{"location":"tools/tool-library/github-tool/#authentication","title":"Authentication","text":"<p>Requires a GitHub API key (personal access token) which can be:</p> <ul> <li>Passed during initialization as <code>api_key</code></li> <li>Set in environment variables</li> <li>Stored in Agentic's secrets system as <code>GITHUB_API_KEY</code></li> </ul>"},{"location":"tools/tool-library/github-tool/#initialization","title":"Initialization","text":"<pre><code>def __init__(api_key: str = None, default_repo: str = None)\n</code></pre> <p>Parameters:</p> <ul> <li><code>api_key (str)</code>: GitHub API token (optional if set in environment or secrets)</li> <li><code>default_repo (str)</code>: Default repository to use in format \"owner/repo\"</li> </ul>"},{"location":"tools/tool-library/github-tool/#remote-api-methods","title":"Remote API Methods","text":""},{"location":"tools/tool-library/github-tool/#search_repositories","title":"search_repositories","text":"<pre><code>async def search_repositories(thread_context: ThreadContext, query: str, language: Optional[str] = None, sort: str = 'stars', order: str = 'desc') -&gt; dict\n</code></pre> <p>Search for GitHub repositories.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>query (str)</code>: Search keywords</li> <li><code>language (Optional[str])</code>: Filter repositories by programming language</li> <li><code>sort (str)</code>: Criteria to sort results ('stars', 'forks', 'updated')</li> <li><code>order (str)</code>: Order of results ('asc', 'desc')</li> </ul> <p>Returns: A dictionary containing search results.</p>"},{"location":"tools/tool-library/github-tool/#create_github_issue","title":"create_github_issue","text":"<pre><code>async def create_github_issue(thread_context: ThreadContext, title: str, body: str, labels: List[str] = None, repo_owner: Optional[str] = None, repo_name: Optional[str] = None) -&gt; Dict[str, Any]\n</code></pre> <p>Create a new issue in a GitHub repository.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>title (str)</code>: Title of the issue</li> <li><code>body (str)</code>: Body text of the issue</li> <li><code>labels (List[str])</code>: Labels to apply to the issue</li> <li><code>repo_owner (Optional[str])</code>: Repository owner (defaults to default_repo owner)</li> <li><code>repo_name (Optional[str])</code>: Repository name (defaults to default_repo name)</li> </ul> <p>Returns: The created issue data or an error message.</p>"},{"location":"tools/tool-library/github-tool/#get_github_issues","title":"get_github_issues","text":"<pre><code>async def get_github_issues(thread_context: ThreadContext, state: str = 'open', labels: Optional[str] = None, assignee: Optional[str] = None, creator: Optional[str] = None, mentioned: Optional[str] = None, since: Optional[str] = None, repo_owner: Optional[str] = None, repo_name: Optional[str] = None) -&gt; pd.DataFrame\n</code></pre> <p>List issues in a repository.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>state (str)</code>: State of issues to return ('open', 'closed', 'all')</li> <li><code>labels (Optional[str])</code>: Comma-separated list of label names</li> <li><code>assignee (Optional[str])</code>: Username of assigned user</li> <li><code>creator (Optional[str])</code>: Username of issue creator</li> <li><code>mentioned (Optional[str])</code>: Username mentioned in issues</li> <li><code>since (Optional[str])</code>: ISO 8601 timestamp for issues updated after this date</li> <li><code>repo_owner (Optional[str])</code>: Repository owner</li> <li><code>repo_name (Optional[str])</code>: Repository name</li> </ul> <p>Returns: A pandas DataFrame containing issue data.</p>"},{"location":"tools/tool-library/github-tool/#create_pull_request","title":"create_pull_request","text":"<pre><code>async def create_pull_request(thread_context: ThreadContext, title: str, body: str, head: str, base: str, repo_owner: Optional[str] = None, repo_name: Optional[str] = None) -&gt; Dict[str, Any]\n</code></pre> <p>Create a new pull request.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>title (str)</code>: Title of the pull request</li> <li><code>body (str)</code>: Body of the pull request</li> <li><code>head (str)</code>: The branch with changes</li> <li><code>base (str)</code>: The branch to merge changes into</li> <li><code>repo_owner (Optional[str])</code>: Repository owner</li> <li><code>repo_name (Optional[str])</code>: Repository name</li> </ul> <p>Returns: Created pull request data.</p>"},{"location":"tools/tool-library/github-tool/#get_repository_contents","title":"get_repository_contents","text":"<pre><code>async def get_repository_contents(thread_context: ThreadContext, path: str = '', repo_owner: Optional[str] = None, repo_name: Optional[str] = None) -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get contents of a repository.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>path (str)</code>: Path to the content</li> <li><code>repo_owner (Optional[str])</code>: Repository owner</li> <li><code>repo_name (Optional[str])</code>: Repository name</li> </ul> <p>Returns: List of repository contents.</p>"},{"location":"tools/tool-library/github-tool/#search_in_repo","title":"search_in_repo","text":"<pre><code>async def search_in_repo(thread_context: ThreadContext, query: str, repo_owner: Optional[str] = None, repo_name: Optional[str] = None) -&gt; List[Dict[str, str]]\n</code></pre> <p>Search for code within a specific repository.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>query (str)</code>: Search terms or code snippet to find</li> <li><code>repo_owner (Optional[str])</code>: Repository owner</li> <li><code>repo_name (Optional[str])</code>: Repository name</li> </ul> <p>Returns: List of dictionaries with file paths, URLs, and code snippets.</p>"},{"location":"tools/tool-library/github-tool/#download_repo_file","title":"download_repo_file","text":"<pre><code>async def download_repo_file(thread_context: ThreadContext, file_path: str, repo_owner: Optional[str] = None, repo_name: Optional[str] = None, branch: Optional[str] = None, local_file_name: Optional[str] = None) -&gt; str\n</code></pre> <p>Download a file from a repository to local storage.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>file_path (str)</code>: Path to the file in the repository</li> <li><code>repo_owner (Optional[str])</code>: Repository owner</li> <li><code>repo_name (Optional[str])</code>: Repository name</li> <li><code>branch (Optional[str])</code>: Branch to download from</li> <li><code>local_file_name (Optional[str])</code>: Local filename to save as</li> </ul> <p>Returns: Local filename of the downloaded file or an error message.</p>"},{"location":"tools/tool-library/github-tool/#local-git-operations","title":"Local Git Operations","text":""},{"location":"tools/tool-library/github-tool/#clone_repository","title":"clone_repository","text":"<pre><code>def clone_repository(thread_context: ThreadContext, repo_url: str, directory_path: str) -&gt; str\n</code></pre> <p>Clone a git repository from the given URL.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>repo_url (str)</code>: URL of the repository to clone</li> <li><code>directory_path (str)</code>: Path where the repository should be cloned</li> </ul> <p>Returns: Status message.</p>"},{"location":"tools/tool-library/github-tool/#create_commit","title":"create_commit","text":"<pre><code>def create_commit(thread_context: ThreadContext, repo_path: str, message: str, files: Optional[List[str]] = None) -&gt; str\n</code></pre> <p>Create a commit in the local repository.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>repo_path (str)</code>: Path to the local repository</li> <li><code>message (str)</code>: Commit message</li> <li><code>files (Optional[List[str]])</code>: List of file paths to commit</li> </ul> <p>Returns: Status message.</p>"},{"location":"tools/tool-library/github-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import GithubTool\n\n# Create a GitHub tool with authentication\ngithub_tool = GithubTool(api_key=\"&lt;YOUR-API-KEY&gt;\" default_repo=\"supercog-ai/agentic\")\n\n# Create an agent with GitHub capabilities\ngithub_agent = Agent(\n    name=\"GitHub Assistant\",\n    instructions=\"You help users interact with GitHub repositories.\",\n    tools=[github_tool]\n)\n\n# Use the agent to search repositories\nresponse = github_agent &lt;&lt; \"Find the top 5 Python repositories for machine learning\"\nprint(response)\n\n# Use the agent for repository operations\nresponse = github_agent &lt;&lt; \"Create an issue in the default repository with title 'Update documentation' and body 'The installation docs need updating.'\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/github-tool/#notes","title":"Notes","text":"<ul> <li>Most methods support either direct repository specification or using the default repository</li> <li>The tool handles authentication automatically once API key is provided</li> <li>For extensive git operations, local clones are created in a managed directory</li> <li>All API requests use asynchronous HTTP calls for better performance</li> <li>The tool provides both high-level GitHub API operations and low-level git operations</li> </ul>"},{"location":"tools/tool-library/google-news-tool/","title":"GoogleNewsTool","text":"<p>The <code>GoogleNewsTool</code> provides access to Google News articles and headlines through a variety of search and filtering methods. This tool allows your agents to retrieve current news, topic-specific news, perform advanced searches, and analyze trending topics.</p>"},{"location":"tools/tool-library/google-news-tool/#features","title":"Features","text":"<ul> <li>Get top headlines from Google News</li> <li>Search for news by topic, keyword, or location</li> <li>Advanced search options (exact phrases, exclusions, site-specific searches)</li> <li>Download and extract full article content</li> <li>Analyze trending and local topics</li> </ul>"},{"location":"tools/tool-library/google-news-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/google-news-tool/#get_top_headlines","title":"get_top_headlines","text":"<pre><code>def get_top_headlines(language: str = \"en\", country: str = \"US\") -&gt; pd.DataFrame\n</code></pre> <p>Retrieves the current top headlines from Google News.</p> <p>Parameters:</p> <ul> <li><code>language (str)</code>: The language code (default: \"en\")</li> <li><code>country (str)</code>: The country code (default: \"US\")</li> </ul> <p>Returns: A pandas DataFrame containing the top headlines.</p>"},{"location":"tools/tool-library/google-news-tool/#query_topic","title":"query_topic","text":"<pre><code>def query_topic(topic: str, language: str = \"en\", country: str = \"US\") -&gt; pd.DataFrame\n</code></pre> <p>Retrieves news articles related to a specific topic.</p> <p>Parameters:</p> <ul> <li><code>topic (str)</code>: The topic to search for</li> <li><code>language (str)</code>: The language code (default: \"en\")</li> <li><code>country (str)</code>: The country code (default: \"US\")</li> </ul> <p>Returns: A pandas DataFrame containing news articles related to the topic.</p>"},{"location":"tools/tool-library/google-news-tool/#query_news","title":"query_news","text":"<pre><code>def query_news(query: str, language: str = \"en\", country: str = \"US\", before: date = None, after: date = None, back_days: int = 1, exact_phrase: str = None, exclude_terms: List[str] = None, site: str = None, in_title: bool = False, in_url: bool = False, all_in_text: bool = False) -&gt; pd.DataFrame\n</code></pre> <p>Performs an advanced search for news articles with multiple filtering options.</p> <p>Parameters:</p> <ul> <li><code>query (str)</code>: The main search query</li> <li><code>language (str)</code>: The language code (default: \"en\")</li> <li><code>country (str)</code>: The country code (default: \"US\")</li> <li><code>before (Optional[date])</code>: End date for articles</li> <li><code>after (Optional[date])</code>: Start date for articles</li> <li><code>back_days (int)</code>: Number of days back to search (default: 1)</li> <li><code>exact_phrase (Optional[str])</code>: Phrase that must appear exactly as written</li> <li><code>exclude_terms (Optional[List[str]])</code>: Terms to exclude from results</li> <li><code>site (Optional[str])</code>: Limit search to a specific news source</li> <li><code>in_title (bool)</code>: Search only in article titles (default: False)</li> <li><code>in_url (bool)</code>: Search only in article URLs (default: False)</li> <li><code>all_in_text (bool)</code>: Require all words in the article text (default: False)</li> </ul> <p>Returns: A pandas DataFrame containing the search results.</p>"},{"location":"tools/tool-library/google-news-tool/#get_category_news","title":"get_category_news","text":"<pre><code>def get_category_news(category: str, language: str = \"en\", country: str = \"US\") -&gt; List[NewsItem]\n</code></pre> <p>Retrieves news from a specific category.</p> <p>Parameters:</p> <ul> <li><code>category (str)</code>: One of 'WORLD', 'NATION', 'BUSINESS', 'TECHNOLOGY', 'ENTERTAINMENT', 'SCIENCE', 'SPORTS', 'HEALTH'</li> <li><code>language (str)</code>: The language code (default: \"en\")</li> <li><code>country (str)</code>: The country code (default: \"US\")</li> </ul> <p>Returns: A pandas DataFrame containing news articles in the specified category.</p>"},{"location":"tools/tool-library/google-news-tool/#get_location_news","title":"get_location_news","text":"<pre><code>def get_location_news(location: str, language: str = \"en\", country: str = \"US\", max_results: int = 10) -&gt; List[NewsItem]\n</code></pre> <p>Retrieves news related to a specific location.</p> <p>Parameters:</p> <ul> <li><code>location (str)</code>: The location to get news for (e.g., \"New York\", \"Tokyo\")</li> <li><code>language (str)</code>: The language code (default: \"en\")</li> <li><code>country (str)</code>: The country code (default: \"US\")</li> <li><code>max_results (int)</code>: Maximum number of results (default: 10)</li> </ul> <p>Returns: A pandas DataFrame containing location-specific news.</p>"},{"location":"tools/tool-library/google-news-tool/#get_local_topics","title":"get_local_topics","text":"<pre><code>def get_local_topics(location: str, language: str = \"en\", country: str = \"US\", num_topics: int = 10) -&gt; Dict[str, Any]\n</code></pre> <p>Analyzes news to extract trending topics for a specific location.</p> <p>Parameters:</p> <ul> <li><code>location (str)</code>: The location to analyze (e.g., \"New York\", \"Tokyo\")</li> <li><code>language (str)</code>: The language code (default: \"en\")</li> <li><code>country (str)</code>: The country code (default: \"US\")</li> <li><code>num_topics (int)</code>: Number of topics to return (default: 10)</li> </ul> <p>Returns: A dictionary containing trending local topics, their frequencies, and sample headlines.</p>"},{"location":"tools/tool-library/google-news-tool/#get_trending_topics","title":"get_trending_topics","text":"<pre><code>def get_trending_topics(language: str = \"en\", country: str = \"US\", num_topics: int = 10) -&gt; List[str]\n</code></pre> <p>Retrieves the currently trending topics on Google News.</p> <p>Parameters:</p> <ul> <li><code>language (str)</code>: The language code (default: \"en\")</li> <li><code>country (str)</code>: The country code (default: \"US\")</li> <li><code>num_topics (int)</code>: Number of topics to return (default: 10)</li> </ul> <p>Returns: A list of trending topics.</p>"},{"location":"tools/tool-library/google-news-tool/#explain_search_syntax","title":"explain_search_syntax","text":"<pre><code>def explain_search_syntax() -&gt; str\n</code></pre> <p>Provides an explanation of the advanced search syntax for Google News.</p> <p>Returns: A string explaining the search syntax options.</p>"},{"location":"tools/tool-library/google-news-tool/#download_news_article","title":"download_news_article","text":"<pre><code>async def download_news_article(title: str, url: str) -&gt; str\n</code></pre> <p>Downloads and extracts the content of a news article.</p> <p>Parameters:</p> <ul> <li><code>title (str)</code>: The article title</li> <li><code>url (str)</code>: The article URL</li> </ul> <p>Returns: The text content of the article.</p>"},{"location":"tools/tool-library/google-news-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import GoogleNewsTool\n\n# Create a news agent\nnews_agent = Agent(\n    name=\"News Reporter\",\n    instructions=\"You find and summarize news articles on requested topics.\",\n    tools=[GoogleNewsTool()]\n)\n\n# Use the agent\nresponse = news_agent &lt;&lt; \"What are the top headlines today?\"\nprint(response)\n\n# Advanced search\nresponse = news_agent &lt;&lt; \"Find news about climate initiatives from the past week\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/human-interrupt-tool/","title":"HumanInterruptTool","text":"<p>The <code>HumanInterruptTool</code> provides a simple mechanism for agents to pause execution and request input from a human. This tool is essential for implementing human-in-the-loop workflows where an agent needs to gather information or approval before proceeding.</p>"},{"location":"tools/tool-library/human-interrupt-tool/#features","title":"Features","text":"<ul> <li>Pause agent execution to request human input</li> <li>Display custom messages to guide human input</li> <li>Seamlessly resume execution with the provided input</li> <li>Maintain context across the interruption</li> </ul>"},{"location":"tools/tool-library/human-interrupt-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/human-interrupt-tool/#stop_for_input","title":"stop_for_input","text":"<pre><code>def stop_for_input(request_message: str, thread_context: ThreadContext)\n</code></pre> <p>Stop and ask the user for input.</p> <p>Parameters:</p> <ul> <li><code>request_message (str)</code>: The message to display to the human</li> <li><code>thread_context (ThreadContext)</code>: The execution context</li> </ul> <p>Returns: Either the human input (if already provided) or a <code>PauseForInputResult</code> that will pause execution and request input.</p>"},{"location":"tools/tool-library/human-interrupt-tool/#how-it-works","title":"How It Works","text":"<ol> <li>When the <code>stop_for_input</code> method is called, it first checks if input already exists in the run context</li> <li>If input exists, it returns that input immediately</li> <li>If no input exists, it returns a <code>PauseForInputResult</code> which signals the agent framework to:</li> <li>Pause the current execution</li> <li>Display the request message to the human</li> <li>Wait for input</li> <li>Resume execution with the provided input</li> </ol>"},{"location":"tools/tool-library/human-interrupt-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import HumanInterruptTool\n\n# Create an agent with human interruption capability\ninteractive_agent = Agent(\n    name=\"Interactive Assistant\",\n    instructions=\"You help users by gathering necessary information before proceeding.\",\n    tools=[HumanInterruptTool()]\n)\n\n# Use the agent in a conversation requiring human input\nresponse = interactive_agent &lt;&lt; \"Plan a trip to Japan for me\"\nprint(response)\n\n# In this example, the agent might interrupt to ask:\n# \"What is your budget for this trip to Japan?\"\n# After the human provides an answer, the agent continues planning\n</code></pre>"},{"location":"tools/tool-library/human-interrupt-tool/#integration-with-other-tools","title":"Integration with Other Tools","text":"<p>The <code>HumanInterruptTool</code> works well when combined with other tools that might need additional information:</p> <pre><code>from agentic.common import Agent\nfrom agentic.tools import HumanInterruptTool, WeatherTool\n\n# Create an agent with multiple tools\ntravel_agent = Agent(\n    name=\"Travel Planner\",\n    instructions=\"You help plan trips based on weather and user preferences.\",\n    tools=[HumanInterruptTool(), WeatherTool()]\n)\n\n# The agent can get weather data but might need to interrupt for location details\nresponse = travel_agent &lt;&lt; \"What clothes should I pack for my trip next week?\"\n# Agent might pause and ask: \"Where are you traveling to next week?\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/human-interrupt-tool/#best-practices","title":"Best Practices","text":"<ul> <li>Use clear, specific request messages to guide the human on what information is needed</li> <li>Keep interruptions to a minimum to maintain conversation flow</li> <li>Consider whether information could be obtained through other tools before interrupting</li> <li>Store frequently requested information in the agent's memory to avoid repeated interruptions</li> </ul>"},{"location":"tools/tool-library/human-interrupt-tool/#technical-details","title":"Technical Details","text":"<ul> <li>The tool uses the <code>PauseForInputResult</code> class from the Agentic framework</li> <li>Input data is stored in the run context with the key \"input\"</li> <li>The tool is stateless - it doesn't maintain any internal state between calls</li> </ul>"},{"location":"tools/tool-library/image-generator-tool/","title":"ImageGeneratorTool","text":"<p>The <code>ImageGeneratorTool</code> provides capabilities for generating images using OpenAI's image generation models. This tool allows agents to create images based on text prompts and return accessible URLs.</p>"},{"location":"tools/tool-library/image-generator-tool/#features","title":"Features","text":"<ul> <li>Generate images from text descriptions</li> <li>Automatic storage of generated images</li> <li>Return markdown-formatted image URLs</li> <li>Integration with OpenAI's image generation API</li> </ul>"},{"location":"tools/tool-library/image-generator-tool/#authentication","title":"Authentication","text":"<p>Requires an OpenAI API key with access to image generation features. You may have already set this key while setting up agentic. It can be:</p> <ul> <li>Passed to the tool during initialization</li> <li>Set in the environment as <code>OPENAI_API_KEY</code> </li> <li>Stored in Agentic's secrets system as <code>OPENAI_API_KEY</code></li> </ul>"},{"location":"tools/tool-library/image-generator-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/image-generator-tool/#generate_image","title":"generate_image","text":"<pre><code>async def generate_image(prompt: str, thread_context: ThreadContext) -&gt; str\n</code></pre> <p>Generates an image based on the given text prompt.</p> <p>Parameters:</p> <ul> <li><code>prompt (str)</code>: Text description of the image to generate</li> <li><code>thread_context (ThreadContext)</code>: The execution context</li> </ul> <p>Returns: A markdown-formatted string with the URL to the generated image, or an error message.</p>"},{"location":"tools/tool-library/image-generator-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import ImageGeneratorTool\n\n# Create an agent with image generation capabilities\nimage_agent = Agent(\n    name=\"Image Creator\",\n    instructions=\"You create images based on user descriptions.\",\n    tools=[ImageGeneratorTool()]\n)\n\n# Use the agent to generate an image\nresponse = image_agent &lt;&lt; \"Create an image of a futuristic city with flying cars and tall glass buildings\"\nprint(response)\n\n# Output will include: [image result](https://image-url.com)\n</code></pre>"},{"location":"tools/tool-library/image-generator-tool/#behind-the-scenes","title":"Behind the Scenes","text":"<p>The tool works by:</p> <ol> <li>Taking a text prompt describing the desired image</li> <li>Calling OpenAI's image generation API</li> <li>Receiving the generated image URL or data</li> <li>Formatting the result as a markdown link that can be displayed inline</li> </ol>"},{"location":"tools/tool-library/image-generator-tool/#image-storage","title":"Image Storage","text":"<p>The tool can store generated images in one of two ways:</p> <ol> <li>Using the direct URL provided by OpenAI's API</li> <li>Downloading and storing the image in a specified S3 bucket, then returning a public URL</li> </ol>"},{"location":"tools/tool-library/image-generator-tool/#error-handling","title":"Error Handling","text":"<p>The tool handles various error conditions:</p> <ul> <li>Missing API key: Will prompt the user for credentials</li> <li>Generation failures: Returns a descriptive error message</li> <li>Storage issues: Provides details on what went wrong</li> </ul>"},{"location":"tools/tool-library/image-generator-tool/#notes","title":"Notes","text":"<ul> <li>Image quality and accuracy depend on the clarity and specificity of the prompt</li> <li>Uses OpenAI's standard image generation model (DALL-E)</li> <li>Generated images comply with OpenAI's content policy</li> <li>The API key must have sufficient credits for image generation</li> <li>Images are publicly accessible through the returned URLs</li> </ul>"},{"location":"tools/tool-library/imap-tool/","title":"IMAPTool","text":"<p>The <code>IMAPTool</code> provides email inbox access capabilities via the IMAP protocol. This tool allows agents to retrieve, list, and send emails, providing a comprehensive interface for email management.</p>"},{"location":"tools/tool-library/imap-tool/#features","title":"Features","text":"<ul> <li>Connect to email accounts using IMAP</li> <li>List and retrieve emails with filtering options</li> <li>Send and draft emails</li> <li>Extract email content and attachments</li> <li>Process emails with tracking to avoid duplicates</li> </ul>"},{"location":"tools/tool-library/imap-tool/#authentication","title":"Authentication","text":"<p>Requires email credentials which can be:</p> <ul> <li>Stored in Agentic's secrets system as <code>IMAP_USERNAME</code> and <code>IMAP_PASSWORD</code></li> <li>For Gmail, it's recommended to use an App Password rather than your account password</li> </ul>"},{"location":"tools/tool-library/imap-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/imap-tool/#list_folders","title":"list_folders","text":"<pre><code>def list_folders(thread_context: ThreadContext) -&gt; List[str]\n</code></pre> <p>List all available folders in the email account.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> </ul> <p>Returns: List of folder names.</p>"},{"location":"tools/tool-library/imap-tool/#list_emails","title":"list_emails","text":"<pre><code>def list_emails(thread_context: ThreadContext, limit: int = 50, subject_words: str = None, days_back_from_today: int = 1, direct_mail_only: bool = True, folder: str = \"INBOX\") -&gt; List[Dict[str, Any]]\n</code></pre> <p>List emails in the inbox, optionally filtering by subject words.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>limit (int)</code>: Maximum number of emails to return</li> <li><code>subject_words (str)</code>: Filter emails by these words in subject</li> <li><code>days_back_from_today (int)</code>: Number of days back to retrieve</li> <li><code>direct_mail_only (bool)</code>: If True, filter out newsletters and marketing emails</li> <li><code>folder (str)</code>: Folder to search in (e.g., \"INBOX\", \"Sent\", \"Drafts\")</li> </ul> <p>Returns: List of dictionaries containing email information.</p>"},{"location":"tools/tool-library/imap-tool/#send_email","title":"send_email","text":"<pre><code>def send_email(thread_context: ThreadContext, to: str, subject: str, body: str, save_draft: bool = True) -&gt; str\n</code></pre> <p>Drafts or sends an email message.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>to (str)</code>: Recipient email address</li> <li><code>subject (str)</code>: Email subject</li> <li><code>body (str)</code>: Email body content</li> <li><code>save_draft (bool)</code>: If True, save as draft; if False, send immediately</li> </ul> <p>Returns: Confirmation message.</p>"},{"location":"tools/tool-library/imap-tool/#save_email_draft","title":"save_email_draft","text":"<pre><code>def save_email_draft(thread_context: ThreadContext, to: str, subject: str, body: str) -&gt; str\n</code></pre> <p>Save a draft email message.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>to (str)</code>: Recipient email address</li> <li><code>subject (str)</code>: Email subject</li> <li><code>body (str)</code>: Email body content</li> </ul> <p>Returns: Confirmation message.</p>"},{"location":"tools/tool-library/imap-tool/#retrieve_emails","title":"retrieve_emails","text":"<pre><code>def retrieve_emails(thread_context: ThreadContext, limit: int = 5, search_criteria: str = \"\", since_date: Optional[str | datetime] = None, to_address: Optional[str] = None, subject_words: Optional[str] = None, folder: str = \"INBOX\") -&gt; List[Dict[str, Any]]\n</code></pre> <p>Retrieve emails from the specified folder without tracking read status.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>limit (int)</code>: Maximum number of emails to retrieve</li> <li><code>search_criteria (str)</code>: IMAP search string for filtering emails</li> <li><code>since_date (Optional[str | datetime])</code>: Only retrieve emails after this date</li> <li><code>to_address (Optional[str])</code>: Filter emails sent to this address</li> <li><code>subject_words (Optional[str])</code>: Filter emails containing these words in subject</li> <li><code>folder (str)</code>: Email folder to search in</li> </ul> <p>Returns: List of dictionaries containing email data.</p>"},{"location":"tools/tool-library/imap-tool/#retrieve_emails_once","title":"retrieve_emails_once","text":"<pre><code>def retrieve_emails_once(thread_context: ThreadContext, limit: int = 5, search_criteria: str = \"\", since_date: Optional[str | datetime] = None, to_address: Optional[str] = None, subject_words: Optional[str] = None, folder: str = \"INBOX\") -&gt; List[Dict[str, Any]]\n</code></pre> <p>Retrieve emails while tracking which emails have been read.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>limit (int)</code>: Maximum number of emails to retrieve</li> <li><code>search_criteria (str)</code>: IMAP search string for filtering emails</li> <li><code>since_date (Optional[str | datetime])</code>: Only retrieve emails after this date</li> <li><code>to_address (Optional[str])</code>: Filter emails sent to this address</li> <li><code>subject_words (Optional[str])</code>: Filter emails containing these words in subject</li> <li><code>folder (str)</code>: Email folder to search in</li> </ul> <p>Returns: List of dictionaries containing email data (only unread/unprocessed emails).</p>"},{"location":"tools/tool-library/imap-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import IMAPTool\n\n# Create an agent with email capabilities\nemail_agent = Agent(\n    name=\"Email Assistant\",\n    instructions=\"You help manage emails, retrieving and sending messages.\",\n    tools=[IMAPTool()]\n)\n\n# The agent will prompt for IMAP credentials if they aren't already set\n# agentic secrets set IMAP_USERNAME=\"your.email@gmail.com\"\n# agentic secrets set IMAP_PASSWORD=\"your-app-password\"\n\n# Use the agent to check recent emails\nresponse = email_agent &lt;&lt; \"Show me my latest emails\"\nprint(response)\n\n# Use the agent to search for specific emails\nresponse = email_agent &lt;&lt; \"Find emails with 'invoice' in the subject from the last 7 days\"\nprint(response)\n\n# Use the agent to draft an email\nresponse = email_agent &lt;&lt; \"Draft a response to the latest email from my boss\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/imap-tool/#search-criteria-syntax","title":"Search Criteria Syntax","text":"<p>The tool supports IMAP search syntax for advanced filtering:</p> <ul> <li><code>FROM \"sender@example.com\"</code>: Emails from a specific sender</li> <li><code>SUBJECT \"important\"</code>: Emails with a specific subject word</li> <li><code>TO \"recipient@example.com\"</code>: Emails to a specific recipient</li> <li><code>SINCE \"1-Jan-2023\"</code>: Emails since a specific date</li> <li><code>UNSEEN</code>: Unread emails</li> <li><code>FLAGGED</code>: Starred/flagged emails</li> </ul> <p>Criteria can be combined: <code>(FROM \"amazon.com\") AND (SUBJECT \"order\")</code></p>"},{"location":"tools/tool-library/imap-tool/#notes","title":"Notes","text":"<ul> <li>The tool primarily supports Gmail but works with most IMAP-compatible email providers</li> <li>For Gmail, you need to enable \"Less secure app access\" or use an App Password</li> <li>Email attachments are saved to a temporary directory</li> <li>The tool tracks processed emails to avoid duplicates when using <code>retrieve_emails_once</code></li> <li>HTML emails are automatically converted to plain text</li> </ul>"},{"location":"tools/tool-library/linkedin-data-tool/","title":"LinkedinDataTool","text":"<p>The <code>LinkedinDataTool</code> provides access to LinkedIn profile and company data. This tool allows agents to retrieve information about professionals and organizations on LinkedIn through a third-party API.</p>"},{"location":"tools/tool-library/linkedin-data-tool/#features","title":"Features","text":"<ul> <li>Retrieve detailed LinkedIn profile information</li> <li>Get company data by username or domain</li> <li>Search for LinkedIn profiles by various criteria</li> <li>Extract location IDs for more targeted searches</li> </ul>"},{"location":"tools/tool-library/linkedin-data-tool/#authentication","title":"Authentication","text":"<p>Requires a RapidAPI key with access to the LinkedIn Data API, which can be:</p> <ul> <li>Set in the environment as <code>RAPIDAPI_KEY</code></li> <li>Retrieved through the tool's <code>get_api_key</code> method</li> </ul>"},{"location":"tools/tool-library/linkedin-data-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/linkedin-data-tool/#get_linkedin_profile_info","title":"get_linkedin_profile_info","text":"<pre><code>async def get_linkedin_profile_info(profile_url: str) -&gt; str\n</code></pre> <p>Retrieves profile information for a LinkedIn user.</p> <p>Parameters:</p> <ul> <li><code>profile_url (str)</code>: Full LinkedIn profile URL (e.g., https://www.linkedin.com/in/username/)</li> </ul> <p>Returns: A string representation of the profile data as a pandas DataFrame.</p>"},{"location":"tools/tool-library/linkedin-data-tool/#get_company_linkedin_info","title":"get_company_linkedin_info","text":"<pre><code>async def get_company_linkedin_info(company_username_or_domain: str) -&gt; str | pd.DataFrame\n</code></pre> <p>Queries the LinkedIn Data API to get company information either by username or domain.</p> <p>Parameters:</p> <ul> <li><code>company_username_or_domain (str)</code>: Company username (e.g., \"Google\") or domain (e.g., \"google.com\")</li> </ul> <p>Returns: A pandas DataFrame containing company information or an error message.</p>"},{"location":"tools/tool-library/linkedin-data-tool/#linkedin_people_search","title":"linkedin_people_search","text":"<pre><code>async def linkedin_people_search(name: Optional[str] = None, location: Optional[str] = None, job_title: Optional[str] = None, company: Optional[str] = None, start: str = \"0\") -&gt; list[dict]\n</code></pre> <p>Searches for LinkedIn profiles based on various criteria.</p> <p>Parameters:</p> <ul> <li><code>name (Optional[str])</code>: Full name or partial name to search for</li> <li><code>location (Optional[str])</code>: Either a location name (e.g., \"California\") or a geo ID (e.g., \"102095887\")</li> <li><code>job_title (Optional[str])</code>: Job title to search for</li> <li><code>company (Optional[str])</code>: Company name to search for</li> <li><code>start (str)</code>: Start index for pagination (0, 10, 20, etc.)</li> </ul> <p>Returns: A list of dictionaries containing profile information.</p>"},{"location":"tools/tool-library/linkedin-data-tool/#search_location","title":"search_location","text":"<pre><code>async def search_location(keyword: str) -&gt; str\n</code></pre> <p>Search for LinkedIn location ID by keyword.</p> <p>Parameters:</p> <ul> <li><code>keyword (str)</code>: Location name to search for (e.g., \"California\")</li> </ul> <p>Returns: Location ID for the first matching result.</p>"},{"location":"tools/tool-library/linkedin-data-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import LinkedinDataTool\n\n# Set up the API key\n# os.environ[\"RAPIDAPI_KEY\"] = \"your-rapidapi-key\"\n\n# Create an agent with LinkedIn data capabilities\nlinkedin_agent = Agent(\n    name=\"LinkedIn Researcher\",\n    instructions=\"You help gather information about professionals and companies on LinkedIn.\",\n    tools=[LinkedinDataTool()]\n)\n\n# Use the agent to look up profile information\nresponse = linkedin_agent &lt;&lt; \"Find information about Satya Nadella on LinkedIn\"\nprint(response)\n\n# Use the agent to research a company\nresponse = linkedin_agent &lt;&lt; \"Get information about Microsoft from LinkedIn\"\nprint(response)\n\n# Use the agent to search for professionals\nresponse = linkedin_agent &lt;&lt; \"Find data scientists working at Google in California\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/linkedin-data-tool/#response-format","title":"Response Format","text":""},{"location":"tools/tool-library/linkedin-data-tool/#profile-information","title":"Profile Information","text":"<p>The profile data is returned as a DataFrame with fields such as:</p> <ul> <li>Full name</li> <li>Headline</li> <li>Current and past positions</li> <li>Education</li> <li>Skills</li> <li>Location</li> <li>Connection count</li> <li>Profile URL and image URL</li> </ul>"},{"location":"tools/tool-library/linkedin-data-tool/#company-information","title":"Company Information","text":"<p>The company data is returned as a DataFrame with fields such as:</p> <ul> <li>Name</li> <li>Industry</li> <li>Location</li> <li>Website</li> <li>Description</li> <li>Employee count</li> <li>Founded date</li> <li>Specialties</li> <li>Logo URL</li> </ul>"},{"location":"tools/tool-library/linkedin-data-tool/#notes","title":"Notes","text":"<ul> <li>This tool requires a subscription to the \"LinkedIn Data API\" on RapidAPI</li> <li>Rate limits apply based on your RapidAPI subscription plan</li> <li>Results are cached to minimize API calls</li> <li>The tool provides asynchronous methods for better performance</li> <li>Location IDs can be used for more precise searches</li> <li>Search results are automatically converted to pandas DataFrames for easier processing</li> </ul>"},{"location":"tools/tool-library/mcp-tool/","title":"MCPTool","text":"<p>The <code>MCPTool</code> provides a universal wrapper for Model Control Protocol (MCP) servers. This tool allows agents to interact with any MCP-compatible service, enabling access to specialized capabilities through a standardized interface.</p>"},{"location":"tools/tool-library/mcp-tool/#features","title":"Features","text":"<ul> <li>Connect to any MCP server</li> <li>Dynamically discover available tools</li> <li>Execute MCP tool calls with proper formatting</li> <li>Handle asynchronous communication with MCP servers</li> </ul>"},{"location":"tools/tool-library/mcp-tool/#mcp-overview","title":"MCP Overview","text":"<p>The Model Control Protocol (MCP) is a standard for enabling LLMs to interact with external tools. It provides a consistent interface for tool discovery and execution, making it easier to integrate various capabilities into agent systems.</p>"},{"location":"tools/tool-library/mcp-tool/#initialization","title":"Initialization","text":"<pre><code>def __init__(command: str, args: list[str], tool_name: Optional[str] = None, env: Optional[Dict[str, str]] = None)\n</code></pre> <p>Parameters:</p> <ul> <li><code>command (str)</code>: The command to run the MCP server (e.g., \"python3\", \"npx\")</li> <li><code>args (list[str])</code>: Arguments for the command</li> <li><code>tool_name (Optional[str])</code>: Optional specific tool name to use from the MCP server</li> <li><code>env (Optional[Dict[str, str]])</code>: Optional environment variables to pass to the MCP server</li> </ul>"},{"location":"tools/tool-library/mcp-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/mcp-tool/#get_tools","title":"get_tools","text":"<pre><code>def get_tools(self) -&gt; List[Callable]\n</code></pre> <p>Get the available MCP tools in a format compatible with Agentic.</p> <p>Returns: A list of callable functions representing the tools available from the MCP server.</p>"},{"location":"tools/tool-library/mcp-tool/#call_tool","title":"call_tool","text":"<pre><code>async def call_tool(openai_tool: dict) -&gt; Any\n</code></pre> <p>Call an MCP tool with given arguments.</p> <p>Parameters:</p> <ul> <li><code>openai_tool (dict)</code>: Tool call in OpenAI format</li> </ul> <p>Returns: The result from the MCP tool execution.</p>"},{"location":"tools/tool-library/mcp-tool/#cleanup","title":"cleanup","text":"<pre><code>async def cleanup()\n</code></pre> <p>Cleanup MCP session and resources.</p>"},{"location":"tools/tool-library/mcp-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import MCPTool\n\n# Create an MCP tool for a Python-based MCP server\npython_mcp = MCPTool(\n    command=\"python3\",\n    args=[\"./mcp_servers/data_analysis_server.py\"]\n)\n\n# Create an agent with MCP capabilities\nmcp_agent = Agent(\n    name=\"MCP-Enabled Assistant\",\n    instructions=\"You help users by leveraging specialized tools through MCP.\",\n    tools=[python_mcp]\n)\n\n# Use the agent - it will have access to all tools provided by the MCP server\nresponse = mcp_agent &lt;&lt; \"Analyze the trends in this dataset\"\nprint(response)\n\n# Create an MCP tool for a JavaScript-based MCP server\njs_mcp = MCPTool(\n    command=\"npx\",\n    args=[\"./mcp-servers/web-scraper\"],\n    env={\"API_KEY\": \"your-api-key\"}\n)\n\n# Create an agent with the JavaScript MCP capabilities\nweb_agent = Agent(\n    name=\"Web Scraping Assistant\",\n    instructions=\"You help users extract data from websites using specialized tools.\",\n    tools=[js_mcp]\n)\n\n# Use the agent with JavaScript MCP tools\nresponse = web_agent &lt;&lt; \"Extract pricing data from this e-commerce site\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/mcp-tool/#creating-an-mcp-server","title":"Creating an MCP Server","text":"<p>To create your own MCP server that works with this tool:</p> <ol> <li>Implement the MCP protocol (input/output JSON format)</li> <li>Expose your tools with proper schema definitions</li> <li>Make your server executable with command-line arguments</li> </ol> <p>Example Python MCP server:</p> <pre><code>from mcp import StdioServer, Tool, schema\n\n@schema.tool(\"calculator\", description=\"Performs calculations\")\ndef calculator(expression: str) -&gt; float:\n    \"\"\"Calculate the result of a mathematical expression\"\"\"\n    return eval(expression)\n\n# Create and run MCP server\nserver = StdioServer(tools=[calculator])\nserver.run()\n</code></pre>"},{"location":"tools/tool-library/mcp-tool/#notes","title":"Notes","text":"<ul> <li>The MCPTool automatically handles session initialization and cleanup</li> <li>The tool handles conversion between OpenAI tool format and MCP format</li> <li>Each tool function will have proper documentation based on the MCP schema</li> <li>The tool works with both synchronous and asynchronous agent frameworks</li> </ul>"},{"location":"tools/tool-library/meeting-baas-tool/","title":"MeetingBaasTool","text":"<p>The <code>MeetingBaasTool</code> provides capabilities for managing video meetings, recording transcripts, and generating summaries. This tool integrates with the MeetingBaaS API to join online meetings, record conversations, and process the resulting data.</p>"},{"location":"tools/tool-library/meeting-baas-tool/#features","title":"Features","text":"<ul> <li>Join video meetings with a bot participant</li> <li>Record and transcribe meeting conversations</li> <li>Generate detailed meeting summaries</li> <li>Store and retrieve meeting information</li> <li>Answer questions about past meetings using RAG (Retrieval Augmented Generation)</li> </ul>"},{"location":"tools/tool-library/meeting-baas-tool/#authentication","title":"Authentication","text":"<p>Requires a MeetingBaaS API key, which can be stored in Agentic's secrets system as <code>MEETING_BAAS_API_KEY</code>.</p>"},{"location":"tools/tool-library/meeting-baas-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/meeting-baas-tool/#join_meeting","title":"join_meeting","text":"<pre><code>def join_meeting(meeting_url: str, thread_context: ThreadContext, bot_name: str = \"Meeting Assistant\") -&gt; dict\n</code></pre> <p>Join a video meeting and start recording.</p> <p>Parameters:</p> <ul> <li><code>meeting_url (str)</code>: URL of the meeting to join</li> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>bot_name (str)</code>: Name to display for the bot in the meeting (default: \"Meeting Assistant\")</li> </ul> <p>Returns: A dictionary with status information and meeting ID.</p>"},{"location":"tools/tool-library/meeting-baas-tool/#get_transcript","title":"get_transcript","text":"<pre><code>def get_transcript(meeting_id: str) -&gt; dict\n</code></pre> <p>Get the transcript for a specific meeting and save it to the database if not already present.</p> <p>Parameters:</p> <ul> <li><code>meeting_id (str)</code>: The ID of the meeting</li> </ul> <p>Returns: A dictionary containing the meeting transcript or an error message.</p>"},{"location":"tools/tool-library/meeting-baas-tool/#get_summary","title":"get_summary","text":"<pre><code>def get_summary(meeting_id: str) -&gt; dict\n</code></pre> <p>Generate a detailed summary of the meeting.</p> <p>Parameters:</p> <ul> <li><code>meeting_id (str)</code>: The ID of the meeting</li> </ul> <p>Returns: A dictionary containing the generated summary or an error message.</p>"},{"location":"tools/tool-library/meeting-baas-tool/#list_meetings","title":"list_meetings","text":"<pre><code>def list_meetings() -&gt; dict\n</code></pre> <p>List all recorded meetings.</p> <p>Returns: A dictionary containing a list of meetings with metadata.</p>"},{"location":"tools/tool-library/meeting-baas-tool/#get_meeting_info","title":"get_meeting_info","text":"<pre><code>def get_meeting_info(meeting_id: str) -&gt; dict\n</code></pre> <p>Retrieve detailed information about a specific meeting.</p> <p>Parameters:</p> <ul> <li><code>meeting_id (str)</code>: The ID of the meeting</li> </ul> <p>Returns: A dictionary containing comprehensive meeting information.</p>"},{"location":"tools/tool-library/meeting-baas-tool/#answer_question","title":"answer_question","text":"<pre><code>def answer_question(meeting_id: str, question: str) -&gt; dict\n</code></pre> <p>Answer a question related to a specific meeting using RAG.</p> <p>Parameters:</p> <ul> <li><code>meeting_id (str)</code>: The ID of the meeting</li> <li><code>question (str)</code>: The question to answer about the meeting</li> </ul> <p>Returns: A dictionary containing relevant context to answer the question.</p>"},{"location":"tools/tool-library/meeting-baas-tool/#process_webhook","title":"process_webhook","text":"<pre><code>def process_webhook(webhook_data: dict) -&gt; dict\n</code></pre> <p>Process webhook data received from MeetingBaaS.</p> <p>Parameters:</p> <ul> <li><code>webhook_data (dict)</code>: The webhook data received from MeetingBaaS</li> </ul> <p>Returns: A dictionary containing the processing status and any updated meeting information.</p>"},{"location":"tools/tool-library/meeting-baas-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import MeetingBaasTool\n\n# Create an agent with meeting capabilities\nmeeting_agent = Agent(\n    name=\"Meeting Assistant\",\n    instructions=\"You help users join, record, and summarize video meetings.\",\n    tools=[MeetingBaasTool()]\n)\n\n# Use the agent to join a meeting\nresponse = meeting_agent &lt;&lt; \"Join the Zoom meeting at https://zoom.us/j/123456789\"\nprint(response)\n\n# Use the agent to get a meeting transcript\nresponse = meeting_agent &lt;&lt; \"Get the transcript from my last meeting\"\nprint(response)\n\n# Use the agent to summarize a meeting\nresponse = meeting_agent &lt;&lt; \"Summarize what was discussed in the marketing meeting yesterday\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/meeting-baas-tool/#database-storage","title":"Database Storage","text":"<p>The tool automatically stores meeting information in a SQLite database:</p> <ul> <li>Meeting metadata (ID, URL, start/end time, status)</li> <li>Transcripts</li> <li>Generated summaries</li> <li>Attendees</li> <li>Recording URLs</li> </ul>"},{"location":"tools/tool-library/meeting-baas-tool/#rag-implementation","title":"RAG Implementation","text":"<p>The tool uses Retrieval Augmented Generation for answering questions about meetings:</p> <ol> <li>Meeting summaries are indexed in a vector database (Weaviate)</li> <li>Embeddings are created using the BAAI/bge-small-en-v1.5 model</li> <li>When a question is asked, relevant chunks of meeting content are retrieved</li> <li>The context is returned for the agent to formulate an answer</li> </ol>"},{"location":"tools/tool-library/meeting-baas-tool/#webhook-support","title":"Webhook Support","text":"<p>The tool can receive and process webhooks from the MeetingBaaS service:</p> <ul> <li>Meeting status changes</li> <li>Completion notifications</li> <li>Error reports</li> </ul>"},{"location":"tools/tool-library/meeting-baas-tool/#notes","title":"Notes","text":"<ul> <li>Requires a public URL for webhook callbacks (uses devtunnel for local development)</li> <li>Transcription is performed by the MeetingBaaS service</li> <li>Summaries are generated using OpenAI's GPT-4o model</li> <li>Meeting bots can join Zoom, Microsoft Teams, Google Meet, and other platforms</li> <li>Vector storage enables semantic search across meeting content</li> </ul>"},{"location":"tools/tool-library/playwright-tool/","title":"PlaywrightTool","text":"<p>The <code>PlaywrightTool</code> provides browser automation capabilities using the Playwright framework. This tool allows agents to navigate websites, extract content, take screenshots, and interact with web elements.</p>"},{"location":"tools/tool-library/playwright-tool/#features","title":"Features","text":"<ul> <li>Navigate to URLs and retrieve page content</li> <li>Extract text content from web pages</li> <li>Convert HTML to Markdown for better readability</li> <li>Take screenshots of full pages or specific elements</li> <li>Click on elements to interact with web pages</li> </ul>"},{"location":"tools/tool-library/playwright-tool/#initialization","title":"Initialization","text":"<pre><code>def __init__(headless: bool = False)\n</code></pre> <p>Parameters:</p> <ul> <li><code>headless (bool)</code>: Whether to run browser in headless mode (invisible) or visible mode (default: False)</li> </ul>"},{"location":"tools/tool-library/playwright-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/playwright-tool/#navigate_to_url","title":"navigate_to_url","text":"<pre><code>def navigate_to_url(thread_context: ThreadContext, url: str) -&gt; str\n</code></pre> <p>Navigate to a URL and return the page title.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>url (str)</code>: URL to navigate to</li> </ul> <p>Returns: The page title, or None if navigation failed.</p>"},{"location":"tools/tool-library/playwright-tool/#extract_text","title":"extract_text","text":"<pre><code>def extract_text(thread_context: ThreadContext, selector: str, convert_to_markdown: bool = True) -&gt; str\n</code></pre> <p>Extract text content from elements matching a CSS selector.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>selector (str)</code>: CSS selector to find elements</li> <li><code>convert_to_markdown (bool)</code>: Whether to convert HTML to Markdown (default: True)</li> </ul> <p>Returns: Extracted text or Markdown content.</p>"},{"location":"tools/tool-library/playwright-tool/#take_screenshot","title":"take_screenshot","text":"<pre><code>def take_screenshot(thread_context: ThreadContext, selector: str = None, filename: str = None) -&gt; str\n</code></pre> <p>Take a screenshot of the page or a specific element.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>selector (str)</code>: Optional CSS selector to screenshot specific element</li> <li><code>filename (str)</code>: Optional filename to save screenshot (defaults to timestamp)</li> </ul> <p>Returns: Path to saved screenshot file or error message.</p>"},{"location":"tools/tool-library/playwright-tool/#click_element","title":"click_element","text":"<pre><code>def click_element(thread_context: ThreadContext, selector: str) -&gt; str\n</code></pre> <p>Click an element matching the CSS selector.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>selector (str)</code>: CSS selector for element to click</li> </ul> <p>Returns: Success or failure message.</p>"},{"location":"tools/tool-library/playwright-tool/#download_pages","title":"download_pages","text":"<pre><code>def download_pages(thread_context: ThreadContext, pages: List[str]) -&gt; list[tuple[str, str, str]]\n</code></pre> <p>Downloads the content of multiple pages.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>pages (List[str])</code>: List of URLs to download</li> </ul> <p>Returns: A list of tuples (url, title, content) for each page.</p>"},{"location":"tools/tool-library/playwright-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import PlaywrightTool\n\n# Create a browser automation tool with visible browser (for debugging)\nbrowser_tool = PlaywrightTool(headless=False)\n\n# Create an agent with browser automation capabilities\nbrowser_agent = Agent(\n    name=\"Web Browser\",\n    instructions=\"You help users navigate and extract information from websites.\",\n    tools=[browser_tool]\n)\n\n# Use the agent to navigate and extract information\nresponse = browser_agent &lt;&lt; \"Go to https://example.com and extract all paragraph text\"\nprint(response)\n\n# Use the agent to take a screenshot\nresponse = browser_agent &lt;&lt; \"Go to https://weather.gov and take a screenshot of the forecast\"\nprint(response)\n\n# Use the agent for interactive browsing\nresponse = browser_agent &lt;&lt; \"Go to https://news.ycombinator.com and click on the top story\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/playwright-tool/#css-selectors","title":"CSS Selectors","text":"<p>The tool uses CSS selectors to identify elements. Some common examples:</p> <ul> <li><code>p</code> - All paragraph elements</li> <li><code>#main</code> - Element with ID \"main\"</li> <li><code>.article</code> - Elements with class \"article\"</li> <li><code>h1, h2, h3</code> - All heading elements</li> <li><code>article &gt; p</code> - Paragraphs directly inside article elements</li> </ul>"},{"location":"tools/tool-library/playwright-tool/#browser-management","title":"Browser Management","text":"<p>The tool manages browser resources automatically:</p> <ul> <li>Browser is launched on first use</li> <li>Resources are cleaned up properly when the agent is done</li> <li>If the browser crashes, it will be restarted on next use</li> </ul>"},{"location":"tools/tool-library/rag-tool/","title":"RAGTool","text":"<p>The <code>RAGTool</code> provides Retrieval-Augmented Generation (RAG) capabilities for agents. This tool allows agents to manage knowledge bases, index content, and perform semantic searches to retrieve relevant information.</p>"},{"location":"tools/tool-library/rag-tool/#features","title":"Features","text":"<ul> <li>Create and manage knowledge indexes</li> <li>Save and index content from text, files, or URLs</li> <li>Search indexed content using semantic or hybrid search</li> <li>Review and manage indexed documents</li> <li>Chunking and embedding of content</li> </ul>"},{"location":"tools/tool-library/rag-tool/#initialization","title":"Initialization","text":"<pre><code>def __init__(default_index: str = \"knowledge_base\", index_paths: list[str] = [])\n</code></pre> <p>Parameters:</p> <ul> <li><code>default_index (str)</code>: Name of the default vector store index (default: \"knowledge_base\")</li> <li><code>index_paths (list[str])</code>: List of files or glob patterns to index during initialization</li> </ul>"},{"location":"tools/tool-library/rag-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/rag-tool/#save_content_to_knowledge_index","title":"save_content_to_knowledge_index","text":"<pre><code>def save_content_to_knowledge_index(thread_context: ThreadContext, content: str = None, index_name: str = None) -&gt; str\n</code></pre> <p>Save content to a knowledge index. Accepts both text and file paths/URLs.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The execution context</li> <li><code>content (str)</code>: Text content or path to file/URL to index</li> <li><code>index_name (str)</code>: Name of the index to save to (defaults to default_index)</li> </ul> <p>Returns: Status message indicating success or failure.</p>"},{"location":"tools/tool-library/rag-tool/#search_knowledge_index","title":"search_knowledge_index","text":"<pre><code>def search_knowledge_index(query: str = None, limit: int = 1, hybrid: bool = False) -&gt; str\n</code></pre> <p>Search a knowledge index for relevant documents.</p> <p>Parameters:</p> <ul> <li><code>query (str)</code>: The search query</li> <li><code>limit (int)</code>: Maximum number of results to return (default: 1)</li> <li><code>hybrid (bool)</code>: Whether to use hybrid search (vector + text) (default: False)</li> </ul> <p>Returns: List of dictionaries containing search results with metadata.</p>"},{"location":"tools/tool-library/rag-tool/#list_documents","title":"list_documents","text":"<pre><code>def list_documents() -&gt; str\n</code></pre> <p>List all documents in a knowledge index.</p> <p>Returns: String containing document information.</p>"},{"location":"tools/tool-library/rag-tool/#review_full_document","title":"review_full_document","text":"<pre><code>def review_full_document(document_id: str = None) -&gt; str\n</code></pre> <p>Review a full document from a knowledge index.</p> <p>Parameters:</p> <ul> <li><code>document_id (str)</code>: ID of the document to review</li> </ul> <p>Returns: String containing the full document content.</p>"},{"location":"tools/tool-library/rag-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import RAGTool\n\n# Create a RAG tool with default settings\nrag_tool = RAGTool()\n\n# Create an agent with RAG capabilities\nknowledge_agent = Agent(\n    name=\"Knowledge Assistant\",\n    instructions=\"You help users find information in the knowledge base.\",\n    tools=[rag_tool]\n)\n\n# Index a file\nresponse = knowledge_agent &lt;&lt; \"Save this document to the knowledge base: https://www.iana.org/reports/2014/transition-plan-201404.pdf\"\nprint(response)\n\n# Search for information\nresponse = knowledge_agent &lt;&lt; \"What does the document say about the transistion of iana?\"\nprint(response)\n\n# Create a RAG tool with pre-indexed files\npre_indexed_rag = RAGTool(\n    default_index=\"documentation\",\n    index_paths=[\"./docs/*.md\"]\n)\n\n# Create an agent with pre-indexed documentation\ndocs_agent = Agent(\n    name=\"Documentation Helper\",\n    instructions=\"You help users find information in the documentation.\",\n    tools=[pre_indexed_rag]\n)\n\n# Use the agent with pre-indexed content\nresponse = docs_agent &lt;&lt; \"How do I install this software?\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/rag-tool/#implementation-details","title":"Implementation Details","text":"<p>The RAGTool uses:</p> <ul> <li>Weaviate as the vector database backend</li> <li>Chunking to break documents into manageable pieces</li> <li>Embedding models to generate vector representations</li> <li>Document metadata tracking for source attribution</li> <li>Automatic deduplication of content</li> </ul>"},{"location":"tools/tool-library/rag-tool/#cli-integration","title":"CLI Integration","text":"<p>The tool integrates with Agentic's CLI for index management:</p> <pre><code># Index a file\nagentic index_file my_index path/to/document.pdf\n\n# Search the index\nagentic search my_index \"my search query\"\n\n# List documents in an index\nagentic list-documents my_index\n</code></pre>"},{"location":"tools/tool-library/rag-tool/#notes","title":"Notes","text":"<ul> <li>The tool automatically handles document processing, chunking, and embedding</li> <li>Content is indexed in real-time</li> <li>Search supports both pure vector similarity and hybrid search</li> <li>Documents can be retrieved in full or as relevant chunks</li> <li>The tool tracks document metadata including source, timestamp, and fingerprints</li> </ul>"},{"location":"tools/tool-library/rest-api-tool/","title":"RestApiTool","text":"<p>The <code>RestApiTool</code> is a powerful tool that enables agents to make HTTP requests to REST APIs. It supports various authentication methods, request types, and content formats, making it suitable for interacting with a wide range of web services.</p> <p>This tool can be used in lieu of a specific tool for an external service. When developing an agent consider first using this tool, and as needs get more specific you can create a more specific tool.</p>"},{"location":"tools/tool-library/rest-api-tool/#features","title":"Features","text":"<ul> <li>Multiple HTTP methods (GET, POST, PUT, PATCH, DELETE)</li> <li>Various authentication methods (Bearer token, Basic auth, Parameter auth)</li> <li>JSON and form data request types</li> <li>Automatic response parsing based on content type</li> <li>Request header customization</li> <li>Configurable request parameters</li> </ul>"},{"location":"tools/tool-library/rest-api-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/rest-api-tool/#prepare_auth_config","title":"prepare_auth_config","text":"<pre><code>async def prepare_auth_config(auth_type: str, username: str = None, password: str = None, token: str = None, token_name: str = \"Bearer\", thread_context: ThreadContext = None) -&gt; AsyncGenerator[Any, Any]\n</code></pre> <p>Constructs an auth_config object to use with later requests.</p> <p>Parameters:</p> <ul> <li><code>auth_type (str)</code>: One of: \"basic\", \"bearer\", \"token\", \"parameter\", or \"none\"</li> <li><code>username (str)</code>: Username for basic auth</li> <li><code>password (str)</code>: Password for basic auth</li> <li><code>token (str)</code>: Token for bearer or parameter auth</li> <li><code>token_name (str)</code>: Name to use with the token (default: \"Bearer\")</li> <li><code>thread_context (ThreadContext)</code>: The execution context</li> </ul> <p>Returns: The variable name of the auth config for use in request calls.</p>"},{"location":"tools/tool-library/rest-api-tool/#add_request_header","title":"add_request_header","text":"<pre><code>def add_request_header(auth_config_var: str, name: str, value: str) -&gt; str\n</code></pre> <p>Add a header to the auth config which was created already.</p> <p>Parameters:</p> <ul> <li><code>auth_config_var (str)</code>: The auth config identifier</li> <li><code>name (str)</code>: Header name</li> <li><code>value (str)</code>: Header value</li> </ul> <p>Returns: \"OK\" on success.</p>"},{"location":"tools/tool-library/rest-api-tool/#get_resource","title":"get_resource","text":"<pre><code>async def get_resource(url: str, params: dict = {}, auth_config_var: Optional[str] = \"\", thread_context: ThreadContext = None)\n</code></pre> <p>Invoke the GET REST endpoint on the indicated URL.</p> <p>Parameters:</p> <ul> <li><code>url (str)</code>: The URL to request</li> <li><code>params (dict)</code>: Query parameters</li> <li><code>auth_config_var (Optional[str])</code>: Auth config identifier</li> <li><code>thread_context (ThreadContext)</code>: The execution context</li> </ul> <p>Returns: The parsed response based on content type.</p>"},{"location":"tools/tool-library/rest-api-tool/#post_resource","title":"post_resource","text":"<pre><code>async def post_resource(path: str, content_type: str = \"application/json\", data: Union[str, dict] = \"{}\", auth_config_var: Optional[str] = \"\")\n</code></pre> <p>Invoke the POST REST endpoint.</p> <p>Parameters:</p> <ul> <li><code>path (str)</code>: The URL to request</li> <li><code>content_type (str)</code>: The content type (default: \"application/json\")</li> <li><code>data (str or dict)</code>: Request body</li> <li><code>auth_config_var (Optional[str])</code>: Auth config identifier</li> </ul> <p>Returns: The parsed response based on content type.</p>"},{"location":"tools/tool-library/rest-api-tool/#put_resource","title":"put_resource","text":"<pre><code>async def put_resource(url: str, data: str = \"{}\", auth_config_var: Optional[str] = \"\")\n</code></pre> <p>Invoke the PUT REST endpoint.</p> <p>Parameters:</p> <ul> <li><code>url (str)</code>: The URL to request</li> <li><code>data (str)</code>: JSON request body</li> <li><code>auth_config_var (Optional[str])</code>: Auth config identifier</li> </ul> <p>Returns: The parsed response based on content type.</p>"},{"location":"tools/tool-library/rest-api-tool/#patch_resource","title":"patch_resource","text":"<pre><code>async def patch_resource(url: str, data: str = \"{}\", auth_config_var: Optional[str] = \"\")\n</code></pre> <p>Invoke the PATCH REST endpoint.</p> <p>Parameters:</p> <ul> <li><code>url (str)</code>: The URL to request</li> <li><code>data (str)</code>: JSON request body</li> <li><code>auth_config_var (Optional[str])</code>: Auth config identifier</li> </ul> <p>Returns: The parsed response based on content type.</p>"},{"location":"tools/tool-library/rest-api-tool/#delete_resource","title":"delete_resource","text":"<pre><code>async def delete_resource(url: str, auth_config_var: Optional[str] = \"\")\n</code></pre> <p>Invoke the DELETE REST endpoint.</p> <p>Parameters:</p> <ul> <li><code>url (str)</code>: The URL to request</li> <li><code>auth_config_var (Optional[str])</code>: Auth config identifier</li> </ul> <p>Returns: The parsed response based on content type.</p>"},{"location":"tools/tool-library/rest-api-tool/#debug_request","title":"debug_request","text":"<pre><code>def debug_request(request_name: str)\n</code></pre> <p>Returns debug information about a request configuration.</p> <p>Parameters:</p> <ul> <li><code>request_name (str)</code>: The request configuration to debug</li> </ul> <p>Returns: A string with debug information.</p>"},{"location":"tools/tool-library/rest-api-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools.rest_tool_v2 import RestApiTool\n\n# Create an agent with REST API capabilities\napi_agent = Agent(\n    name=\"API Client\",\n    instructions=\"You help users interact with REST APIs.\",\n    tools=[RestApiTool()]\n)\n\n# Use the agent to make API calls\nresponse = api_agent &lt;&lt; \"\"\"\nFirst, set up authentication for the GitHub API:\n1. Create a bearer token auth config\n2. Then, get my user information from https://api.github.com/user\n\"\"\"\nprint(response)\n\n# Use the agent to make a POST request with data\nresponse = api_agent &lt;&lt; \"\"\"\nCreate a new gist on GitHub:\n1. Prepare bearer token auth\n2. POST to https://api.github.com/gists with this data:\n{\n  \"description\": \"Example Gist\",\n  \"public\": true,\n  \"files\": {\n    \"example.txt\": {\n      \"content\": \"Hello World\"\n    }\n  }\n}\n\"\"\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/rest-api-tool/#response-handling","title":"Response Handling","text":"<p>The tool automatically processes responses based on their Content-Type:</p> <ul> <li>JSON responses are parsed into Python dictionaries</li> <li>Images are converted to base64 and returned as data URLs</li> <li>HTML, plain text, and CSV are returned as strings</li> <li>Optionally, JSON responses can be converted to pandas DataFrames</li> </ul>"},{"location":"tools/tool-library/rest-api-tool/#authentication-types","title":"Authentication Types","text":"<ol> <li> <p>Basic Auth:    <code>python    # Called by the agent    auth_var = await prepare_auth_config(\"basic\", \"username\", \"password\")</code></p> </li> <li> <p>Bearer Token:    <code>python    # Called by the agent    auth_var = await prepare_auth_config(\"bearer\", token=\"your_token\")</code></p> </li> <li> <p>Parameter Auth:    <code>python    # Called by the agent    auth_var = await prepare_auth_config(\"parameter\", token=\"your_api_key\", token_name=\"api_key\")</code></p> </li> </ol>"},{"location":"tools/tool-library/rest-api-tool/#notes","title":"Notes","text":"<ul> <li>For authenticated requests, <code>prepare_auth_config</code> must be called first</li> <li>The tool supports both synchronous and asynchronous operations</li> <li>Error responses include both status code and response text</li> <li>Secret values can be retrieved from the ThreadContext</li> <li>The tool can be extended with custom response processors</li> <li>Variable substitution using <code>${ENV_VAR}</code> syntax is supported in auth parameters</li> </ul>"},{"location":"tools/tool-library/scaleserp-browser-tool/","title":"ScaleSerpBrowserTool","text":"<p>The <code>ScaleSerpBrowserTool</code> provides web browsing and search capabilities using the SCALESERP API. This tool allows agents to search the web, browse specific URLs, and extract content from web pages.</p>"},{"location":"tools/tool-library/scaleserp-browser-tool/#features","title":"Features","text":"<ul> <li>Web search using SCALESERP API</li> <li>Downloading and content extraction from multiple web pages</li> <li>HTML to text conversion</li> <li>Concurrent page processing for efficiency</li> <li>Fallback to ScrapingBee if primary API fails</li> </ul>"},{"location":"tools/tool-library/scaleserp-browser-tool/#authentication","title":"Authentication","text":"<p>Requires a SCALESERP API key, which can be set in the environment as <code>SCALESERP_API_KEY</code>.</p>"},{"location":"tools/tool-library/scaleserp-browser-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/scaleserp-browser-tool/#browse_web_tool","title":"browse_web_tool","text":"<pre><code>async def browse_web_tool(search: str) -&gt; str\n</code></pre> <p>Browses the web using the SCALESERP API and returns full page contents related to the search term.</p> <p>Parameters:</p> <ul> <li><code>search (str)</code>: The search query or a \"site:\" prefixed URL</li> </ul> <p>Returns: Text content from relevant search results.</p>"},{"location":"tools/tool-library/scaleserp-browser-tool/#download_web_pages","title":"download_web_pages","text":"<pre><code>async def download_web_pages(page_urls: list[str] = []) -&gt; str\n</code></pre> <p>Returns the contents of one or more web pages. Text is extracted from HTML pages.</p> <p>Parameters:</p> <ul> <li><code>page_urls (list[str])</code>: List of URLs to download</li> </ul> <p>Returns: Combined text content from the pages.</p>"},{"location":"tools/tool-library/scaleserp-browser-tool/#convert_downloaded_pages","title":"convert_downloaded_pages","text":"<pre><code>async def convert_downloaded_pages(url_titles: list[tuple], max_count: int) -&gt; list[str]\n</code></pre> <p>Processes and extracts content from downloaded pages.</p> <p>Parameters:</p> <ul> <li><code>url_titles (list[tuple])</code>: List of (url, title) tuples</li> <li><code>max_count (int)</code>: Maximum content length to return</li> </ul> <p>Returns: List of text content from pages.</p>"},{"location":"tools/tool-library/scaleserp-browser-tool/#download_pages","title":"download_pages","text":"<pre><code>async def download_pages(url_titles: list[tuple], max_concurrency=10) -&gt; list[dict]\n</code></pre> <p>Downloads multiple pages concurrently.</p> <p>Parameters:</p> <ul> <li><code>url_titles (list[tuple])</code>: List of (url, title) tuples</li> <li><code>max_concurrency (int)</code>: Maximum number of concurrent downloads</li> </ul> <p>Returns: List of dictionaries containing downloaded page data.</p>"},{"location":"tools/tool-library/scaleserp-browser-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import ScaleSerpBrowserTool\n\n# Set up the API key\n# os.environ[\"SCALESERP_API_KEY\"] = \"your-scaleserp-api-key\"\n\n# Create an agent with web browsing capabilities\nbrowser_agent = Agent(\n    name=\"Web Browser\",\n    instructions=\"You help users search and browse the web for information.\",\n    tools=[ScaleSerpBrowserTool()]\n)\n\n# Use the agent to search the web\nresponse = browser_agent &lt;&lt; \"Find information about quantum computing breakthroughs in 2024\"\nprint(response)\n\n# Use the agent to browse specific websites\nresponse = browser_agent &lt;&lt; \"Visit github.com/supercog-ai/agentic and tell me what it is\"\nprint(response)\n\n# Use the agent to download multiple pages\nresponse = browser_agent &lt;&lt; \"Download and compare the content from these sites: example.com, example.org, example.net\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/scaleserp-browser-tool/#search-syntax","title":"Search Syntax","text":"<p>The tool supports two main search modes:</p> <ol> <li>Regular search: <code>\"quantum computing breakthroughs\"</code> </li> <li> <p>Performs a web search and returns content from the top results</p> </li> <li> <p>Site-specific search: <code>\"site:github.com/supercog-ai\"</code></p> </li> <li>Directly visits the specified URL and returns its content</li> </ol>"},{"location":"tools/tool-library/scaleserp-browser-tool/#html-processing","title":"HTML Processing","text":"<p>The tool automatically:</p> <ul> <li>Extracts text from HTML content</li> <li>Removes boilerplate elements</li> <li>Converts HTML formatting to plain text</li> <li>Limits content length to prevent token overflows</li> </ul>"},{"location":"tools/tool-library/scaleserp-browser-tool/#fallback-mechanism","title":"Fallback Mechanism","text":"<p>If SCALESERP fails or times out, the tool automatically:</p> <ol> <li>Logs the failure</li> <li>Attempts to use ScrapingBee as an alternative search service</li> <li>Proceeds with the available results from either service</li> </ol>"},{"location":"tools/tool-library/tavily-search-tool/","title":"TavilySearchTool","text":"<p>The <code>TavilySearchTool</code> provides web search capabilities using Tavily's search engine API. This tool allows your agents to search the web, get news headlines, and download page content.</p>"},{"location":"tools/tool-library/tavily-search-tool/#features","title":"Features","text":"<ul> <li>Perform general web searches</li> <li>Query specifically for news content</li> <li>Download and extract content from web pages</li> </ul>"},{"location":"tools/tool-library/tavily-search-tool/#authentication","title":"Authentication","text":"<p>Requires a Tavily API key, which can be: - Passed during initialization - Set in environment variables - Stored in Agentic's secrets system as <code>TAVILY_API_KEY</code></p>"},{"location":"tools/tool-library/tavily-search-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/tavily-search-tool/#perform_web_search","title":"perform_web_search","text":"<pre><code>async def perform_web_search(query: str, include_images: bool, include_content: bool, thread_context: ThreadContext) -&gt; List[dict]\n</code></pre> <p>Performs a web search using Tavily's search engine and returns results with metadata.</p> <p>Parameters:</p> <ul> <li><code>query (str)</code>: The search query</li> <li><code>include_images (bool)</code>: Whether to include images in the results</li> <li><code>include_content (bool)</code>: Whether to return the full page contents</li> <li><code>thread_context (ThreadContext)</code>: The agent's running context</li> </ul> <p>Returns: A list of dictionaries containing search results with metadata such as titles, URLs, and snippets.</p>"},{"location":"tools/tool-library/tavily-search-tool/#query_for_news","title":"query_for_news","text":"<pre><code>async def query_for_news(thread_context: ThreadContext, query: str, days_back: int = 1) -&gt; pd.DataFrame | PauseForInputResult\n</code></pre> <p>Returns the latest headlines on a given topic using Tavily's news search.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The agent's running context</li> <li><code>query (str)</code>: The news topic to search for</li> <li><code>days_back (int)</code>: Number of days back to search (default: 1)</li> </ul> <p>Returns: A pandas DataFrame containing news articles related to the query.</p>"},{"location":"tools/tool-library/tavily-search-tool/#tavily_download_pages","title":"tavily_download_pages","text":"<pre><code>async def tavily_download_pages(thread_context: ThreadContext, urls: list[str], include_images: bool = False) -&gt; pd.DataFrame\n</code></pre> <p>Downloads content from one or more web page URLs using Tavily's content extraction API.</p> <p>Parameters:</p> <ul> <li><code>thread_context (ThreadContext)</code>: The agent's running context</li> <li><code>urls (list[str])</code>: List of URLs to download</li> <li><code>include_images (bool)</code>: Whether to include images in the results</li> </ul> <p>Returns: A pandas DataFrame or JSON response containing the extracted content.</p>"},{"location":"tools/tool-library/tavily-search-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import TavilySearchTool\n\n# Create an agent with web search capabilities\nsearch_agent = Agent(\n    name=\"Web Researcher\",\n    instructions=\"You are a helpful assistant that searches the web for information.\",\n    tools=[TavilySearchTool(api_key=\"your_tavily_api_key\")]\n)\n\n# Use the agent\nresponse = search_agent &lt;&lt; \"Find me the latest news on artificial intelligence breakthroughs\"\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/tavily-search-tool/#helper-methods","title":"Helper Methods","text":"<p>The tool also includes helper methods for processing search results and formatting sources:</p> <ul> <li><code>_deduplicate_and_format_sources</code>: Formats search results into a readable string with deduplication</li> <li>Various HTTP request handling methods</li> </ul>"},{"location":"tools/tool-library/tavily-search-tool/#notes","title":"Notes","text":"<ul> <li>The tool automatically handles authentication with the Tavily API</li> <li>JSON responses are automatically converted to pandas DataFrames for easier processing</li> <li>For more information about Tavily's search API, visit tavily.com</li> </ul>"},{"location":"tools/tool-library/text-to-speech-tool/","title":"TextToSpeechTool","text":"<p>The <code>TextToSpeechTool</code> converts text to speech using OpenAI's text-to-speech API. This tool allows agents to generate natural-sounding audio from text input with different voice options.</p>"},{"location":"tools/tool-library/text-to-speech-tool/#features","title":"Features","text":"<ul> <li>Convert text to speech with multiple voice options</li> <li>Handle long texts by splitting into chunks</li> <li>Combine audio segments into a single file</li> <li>Output MP3 files accessible via URL or file path</li> </ul>"},{"location":"tools/tool-library/text-to-speech-tool/#authentication","title":"Authentication","text":"<p>Requires an OpenAI API key, which can be stored in Agentic's secrets system as <code>OPENAI_API_KEY</code>. You likely already have this set up if you've used Agentic before.</p>"},{"location":"tools/tool-library/text-to-speech-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/text-to-speech-tool/#generate_speech_file_from_text","title":"generate_speech_file_from_text","text":"<pre><code>def generate_speech_file_from_text(voice: str, text: Optional[str] = None, input_file_name: Optional[str] = None) -&gt; str\n</code></pre> <p>Generate speech from the given text or input file and save it to a file.</p> <p>Parameters:</p> <ul> <li><code>voice (str)</code>: Voice type to use (one of: alloy, echo, fable, onyx, nova, shimmer)</li> <li><code>text (Optional[str])</code>: The text to be converted to speech</li> <li><code>input_file_name (Optional[str])</code>: Optional name of a file to read text from</li> </ul> <p>Returns: A JSON string containing the URL or file path to the generated audio file.</p>"},{"location":"tools/tool-library/text-to-speech-tool/#voice-options","title":"Voice Options","text":"<p>The tool supports the following OpenAI TTS-1 voices:</p> <ul> <li><code>alloy</code>: Versatile, neutral voice</li> <li><code>echo</code>: An older, deeper voice with gravitas</li> <li><code>fable</code>: An accented, narrative voice</li> <li><code>onyx</code>: A deep, authoritative voice</li> <li><code>nova</code>: A professional, clear voice</li> <li><code>shimmer</code>: A gentler, lighter voice</li> </ul>"},{"location":"tools/tool-library/text-to-speech-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import TextToSpeechTool\n\n# Create an agent with text-to-speech capabilities\ntts_agent = Agent(\n    name=\"Voice Generator\",\n    instructions=\"You convert text to spoken audio with natural-sounding voices.\",\n    tools=[TextToSpeechTool()]\n)\n\n# Generate speech from direct text input\nresponse = tts_agent &lt;&lt; 'Convert this text to speech using the \"nova\" voice: \"Welcome to Agentic, the framework for building intelligent agents. This audio was generated using OpenAI\\'s text-to-speech API.\"'\nprint(response)\n\n# Generate speech from a text file\nresponse = tts_agent &lt;&lt; 'Read the contents of \"speech_script.txt\" using the \"echo\" voice'\nprint(response)\n\n# Generate speech with specific instructions\nresponse = tts_agent &lt;&lt; 'Create a narration for this short story using the \"fable\" voice: \"Once upon a time in a digital realm, agents and humans worked together to solve complex problems...\"'\nprint(response)\n</code></pre>"},{"location":"tools/tool-library/text-to-speech-tool/#how-it-works","title":"How It Works","text":"<p>The tool works as follows:</p> <ol> <li>Takes input text directly or reads from a file</li> <li>If text exceeds OpenAI's TTS limits, splits it into chunks</li> <li>Generates audio for each chunk using OpenAI's TTS API</li> <li>Combines audio segments into a single MP3 file</li> <li>Returns a URL or file path to access the audio</li> </ol>"},{"location":"tools/tool-library/text-to-speech-tool/#technical-implementation","title":"Technical Implementation","text":"<p>The tool uses:</p> <ul> <li>OpenAI's TTS-1 model</li> <li>Pydub for audio processing and concatenation</li> <li>Async operations for efficient processing</li> <li>Temporary storage for intermediate audio files</li> </ul>"},{"location":"tools/tool-library/text-to-speech-tool/#notes","title":"Notes","text":"<ul> <li>Maximum text length is limited by OpenAI's API (4096 characters per chunk)</li> <li>Long texts are automatically split into appropriate chunks</li> <li>MP3 format is used for all audio files</li> <li>File paths in the format <code>file:///path/to/audio.mp3</code> are returned for local files</li> <li>For production use, files can be uploaded to S3 for web accessibility</li> <li>The tool requires the pydub library for audio processing</li> </ul>"},{"location":"tools/tool-library/weather-tool/","title":"WeatherTool","text":"<p>The <code>WeatherTool</code> provides comprehensive weather information using the Open-Meteo API. This tool allows your agents to retrieve current weather conditions, forecasts, historical weather data, and historical averages for any location.</p>"},{"location":"tools/tool-library/weather-tool/#features","title":"Features","text":"<ul> <li>Get current weather conditions</li> <li>Retrieve weather forecasts (hourly or daily)</li> <li>Access historical weather data</li> <li>Calculate historical averages for specific date ranges</li> </ul>"},{"location":"tools/tool-library/weather-tool/#methods","title":"Methods","text":""},{"location":"tools/tool-library/weather-tool/#get_current_weather","title":"get_current_weather","text":"<pre><code>get_current_weather(longitude: str, latitude: str, temperature_unit: str)\n</code></pre> <p>Retrieves the current weather conditions for a specified location.</p> <p>Parameters:</p> <ul> <li><code>longitude (str)</code>: Location longitude (between -180 and 180)</li> <li><code>latitude (str)</code>: Location latitude (between -90 and 90)</li> <li><code>temperature_unit (str)</code>: 'celsius' or 'fahrenheit' (default: 'fahrenheit')</li> </ul> <p>Returns: A detailed string containing current weather information, including:</p> <ul> <li>Temperature</li> <li>Feels like temperature</li> <li>Wind speed and direction</li> <li>Precipitation</li> <li>Cloud cover</li> <li>Humidity</li> <li>Visibility</li> <li>UV index</li> </ul>"},{"location":"tools/tool-library/weather-tool/#get_forecast_weather","title":"get_forecast_weather","text":"<pre><code>get_forecast_weather(longitude: str, latitude: str, forecast_type: str, start_date: str, end_date: str, temperature_unit: str)\n</code></pre> <p>Retrieves forecast weather data for a specific location and time range.</p> <p>Parameters:</p> <ul> <li><code>longitude (str)</code>: Location longitude</li> <li><code>latitude (str)</code>: Location latitude</li> <li><code>forecast_type (str)</code>: 'hourly' (7 days) or 'daily' (16 days)</li> <li><code>start_date (Optional[str])</code>: Start date in YYYY-MM-DD format</li> <li><code>end_date (Optional[str])</code>: End date in YYYY-MM-DD format</li> <li><code>temperature_unit (str)</code>: 'celsius' or 'fahrenheit' (default: 'fahrenheit')</li> </ul> <p>Returns: A formatted string containing detailed forecast data for each day or hour in the requested period.</p>"},{"location":"tools/tool-library/weather-tool/#get_historical_weather","title":"get_historical_weather","text":"<pre><code>get_historical_weather(longitude: str, latitude: str, start_date: str, end_date: str, temperature_unit: str, api_key: str)\n</code></pre> <p>Retrieves historical weather data for a specific location and date range.</p> <p>Parameters:</p> <ul> <li><code>longitude (str)</code>: Location longitude</li> <li><code>latitude (str)</code>: Location latitude</li> <li><code>start_date (str)</code>: Start date in YYYY-MM-DD format</li> <li><code>end_date (str)</code>: End date in YYYY-MM-DD format</li> <li><code>temperature_unit (str)</code>: 'celsius' or 'fahrenheit' (default: 'fahrenheit')</li> <li><code>api_key (Optional[str])</code>: API key for Open-Meteo Archive API</li> </ul> <p>Returns: A formatted string containing historical weather data for each day in the requested period.</p>"},{"location":"tools/tool-library/weather-tool/#get_historical_averages","title":"get_historical_averages","text":"<pre><code>get_historical_averages(longitude: str, latitude: str, target_start_date: str, target_end_date: str, temperature_unit: str, averaging_method: str, max_range_days: int, api_key: str)\n</code></pre> <p>Calculates 5-year historical weather averages for a specific date range.</p> <p>Parameters:</p> <ul> <li><code>longitude (str)</code>: Location longitude</li> <li><code>latitude (str)</code>: Location latitude</li> <li><code>target_start_date (str)</code>: Start date in MM-DD format</li> <li><code>target_end_date (str)</code>: End date in MM-DD format</li> <li><code>temperature_unit (str)</code>: 'celsius' or 'fahrenheit' (default: 'fahrenheit')</li> <li><code>averaging_method (str)</code>: 'mean' or 'median' for calculating averages</li> <li><code>max_range_days (int)</code>: Maximum allowed range in days (default: 14)</li> <li><code>api_key (Optional[str])</code>: API key for Open-Meteo Archive API</li> </ul> <p>Returns: A formatted string containing averaged weather data for the specified date range based on historical patterns.</p>"},{"location":"tools/tool-library/weather-tool/#example-usage","title":"Example Usage","text":"<pre><code>from agentic.common import Agent\nfrom agentic.tools import WeatherTool\n\n# Create an agent with weather capabilities\nweather_agent = Agent(\n    name=\"Weather Assistant\",\n    instructions=\"You provide detailed weather information when asked.\",\n    tools=[WeatherTool()]\n)\n\n# Use the agent\nresponse = weather_agent &lt;&lt; \"What's the current weather in San Francisco?\"\nprint(response)\n</code></pre>"}]}